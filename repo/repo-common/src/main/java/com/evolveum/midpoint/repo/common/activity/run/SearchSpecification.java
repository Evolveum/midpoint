/*
 * Copyright (C) 2010-2021 Evolveum and contributors
 *
 * Licensed under the EUPL-1.2 or later.
 */

package com.evolveum.midpoint.repo.common.activity.run;

import static com.evolveum.midpoint.prism.Referencable.getOid;
import static com.evolveum.midpoint.util.MiscUtil.configCheck;

import static com.evolveum.midpoint.util.MiscUtil.configNonNull;

import static java.util.Objects.requireNonNull;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import javax.xml.namespace.QName;

import com.evolveum.midpoint.prism.Containerable;
import com.evolveum.midpoint.prism.PrismContainerDefinition;
import com.evolveum.midpoint.prism.query.ObjectFilter;
import com.evolveum.midpoint.prism.query.TypedObjectQuery;
import com.evolveum.midpoint.prism.util.CloneUtil;
import com.evolveum.midpoint.repo.common.activity.definition.ObjectSetSpecification;
import com.evolveum.midpoint.repo.common.activity.definition.RepositoryObjectSetSpecificationImpl;
import com.evolveum.midpoint.schema.GetOperationOptions;
import com.evolveum.midpoint.schema.SelectorOptions;
import com.evolveum.midpoint.schema.util.GetOperationOptionsUtil;
import com.evolveum.midpoint.schema.util.ObjectQueryUtil;
import com.evolveum.midpoint.util.exception.ConfigurationException;
import com.evolveum.midpoint.xml.ns._public.common.common_3.*;

import com.google.common.base.MoreObjects;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import com.evolveum.midpoint.prism.PrismContext;
import com.evolveum.midpoint.prism.query.ObjectQuery;
import com.evolveum.midpoint.schema.constants.ObjectTypes;
import com.evolveum.midpoint.util.DebugDumpable;
import com.evolveum.midpoint.util.DebugUtil;
import com.evolveum.midpoint.util.exception.SchemaException;

/**
 * "Compiled" specification of items that are to be processed by {@link SearchBasedActivityRun}.
 * Basically, this is a grouping of type + query + options + "use repo" flag.
 *
 * This object has writable fields, as it can be modified during activity run.
 *
 * There is a subclass dedicated to searching for objects on a resource (`ResourceSearchSpecification`).
 *
 * Note that the archetype present in {@link ObjectSetType} is intentionally not present here.
 * If present, it is included in the query.
 *
 * @param <C> Type of items
 */
public class SearchSpecification<C extends Containerable> implements DebugDumpable, Cloneable {

    /**
     * Container type provided when counting and retrieving objects.
     */
    @NotNull private final Class<C> type;

    /** Query specifying what objects to process. */
    @Nullable private ObjectQuery query;

    /**
     * Options to be used during counting and searching.
     */
    @Nullable private Collection<SelectorOptions<GetOperationOptions>> searchOptions;

    /**
     * Whether we want to use repository directly when counting/searching.
     * Can be "built-in" in the activity, or requested explicitly by the user.
     * In the latter case the raw authorization is checked. (Unless overridden by activity.)
     *
     * Note that this flag is really used only if model processing is available.
     */
    @Nullable private Boolean useRepository;

    public SearchSpecification(
            @NotNull Class<C> type,
            @Nullable ObjectQuery query,
            @Nullable Collection<SelectorOptions<GetOperationOptions>> searchOptions,
            @Nullable Boolean useRepository) {
        this.type = type;
        this.query = query;
        this.searchOptions = searchOptions;
        this.useRepository = useRepository;
    }

    protected SearchSpecification(@NotNull SearchSpecification<C> prototype) {
        this(prototype.type,
                CloneUtil.clone(prototype.query),
                CloneUtil.cloneCollectionMembers(prototype.searchOptions),
                prototype.useRepository);
    }

    @NotNull static <C extends Containerable> SearchSpecification<C> fromRepositoryObjectSetSpecification(
            @NotNull RepositoryObjectSetSpecificationImpl objectSetSpecification) throws SchemaException, ConfigurationException {
        //noinspection unchecked
        Class<C> containerType = (Class<C>) determineContainerType(objectSetSpecification);
        return new SearchSpecification<>(
                containerType,
                createObjectQuery(containerType, objectSetSpecification),
                GetOperationOptionsUtil.optionsBeanToOptions(objectSetSpecification.getSearchOptionsBean()),
                objectSetSpecification.isUseRepositoryDirectly());
    }

    private static @NotNull ObjectQuery createObjectQuery(
            @NotNull Class<? extends Containerable> containerType,
            @NotNull RepositoryObjectSetSpecificationImpl objectSetSpecification)
            throws SchemaException, ConfigurationException {

        PrismContext prismContext = PrismContext.get();
        ObjectQuery bareQuery = createBareQuery(containerType, objectSetSpecification);
        var archetypeOid = objectSetSpecification.getArchetypeOid();
        if (archetypeOid != null) {
            return ObjectQueryUtil.addConjunctions(bareQuery, prismContext.queryFor(containerType)
                    .item(AssignmentHolderType.F_ARCHETYPE_REF).ref(archetypeOid)
                    .buildFilter());
        } else {
            return bareQuery;
        }
    }

    /** Processes "query" or "objectRef" data into a parsed query. */
    private static @NotNull ObjectQuery createBareQuery(
            @NotNull Class<? extends Containerable> containerType,
            @NotNull RepositoryObjectSetSpecificationImpl objectSetSpecification)
            throws SchemaException, ConfigurationException {
        var explicitObjectReferences = objectSetSpecification.getExplicitObjectReferences();
        var queryBean = objectSetSpecification.getQueryBean();
        if (!explicitObjectReferences.isEmpty()) {
            configCheck(queryBean == null, "Both query and explicit objects are present"); // todo origin
            Set<String> oids = new HashSet<>();
            for (ObjectReferenceType ref : explicitObjectReferences) {
                oids.add(
                        configNonNull(
                                getOid(ref),
                                "No OID in explicit object reference in %s",
                                objectSetSpecification)); // todo origin
            }
            assert !oids.isEmpty();
            return PrismContext.get().queryFor(containerType)
                    .id(oids.toArray(new String[0]))
                    .build();
        } else {
            return ObjectQueryUtil.emptyIfNull(
                    PrismContext.get().getQueryConverter().createObjectQuery(containerType, queryBean));
        }
    }

    private static @NotNull Class<?> determineContainerType(@NotNull ObjectSetSpecification set) {
        return getTypeFromName(
                MoreObjects.firstNonNull(
                        set.getObjectType(), ObjectType.COMPLEX_TYPE));
    }

    private static @NotNull Class<?> getTypeFromName(@NotNull QName typeName) {
        Class<?> targetTypeClass = ObjectTypes.getObjectTypeClassIfKnown(typeName);
        if (targetTypeClass == null) {
            PrismContainerDefinition<Containerable> def = PrismContext.get().getSchemaRegistry().findContainerDefinitionByType(typeName);
            if (def == null) {
                throw new IllegalArgumentException("Unsupported container type " + typeName);
            }
            targetTypeClass = def.getTypeClass();
        }
        return targetTypeClass;
    }

    public @NotNull Class<C> getType() {
        return type;
    }

    public @Nullable ObjectQuery getQuery() {
        return query;
    }

    public void setQuery(@Nullable ObjectQuery query) {
        this.query = query;
    }

    public void addFilter(ObjectFilter filter) {
        setQuery(
                ObjectQueryUtil.addConjunctions(query, filter));
    }

    public @Nullable Collection<SelectorOptions<GetOperationOptions>> getSearchOptions() {
        return searchOptions;
    }

    public void setSearchOptions(@Nullable Collection<SelectorOptions<GetOperationOptions>> searchOptions) {
        this.searchOptions = searchOptions;
    }

    Boolean getUseRepository() {
        return useRepository;
    }

    public boolean isUseRepository() {
        return Boolean.TRUE.equals(getUseRepository());
    }

    void setUseRepository(@Nullable Boolean useRepository) {
        this.useRepository = useRepository;
    }

    boolean concernsShadows() {
        return ShadowType.class.equals(requireNonNull(type));
    }

    public boolean isNoFetch() {
        return GetOperationOptions.isNoFetch(getRootOptions());
    }

    public boolean isRaw() {
        return GetOperationOptions.isRaw(getRootOptions());
    }

    @Nullable public GetOperationOptions getRootOptions() {
        return SelectorOptions.findRootOptions(searchOptions);
    }

    void setNoFetchOption() {
        searchOptions = GetOperationOptions.updateToNoFetch(searchOptions);
    }

    @Override
    public String debugDump(int indent) {
        StringBuilder sb = DebugUtil.createTitleStringBuilderLn(getClass(), indent);
        DebugUtil.debugDumpWithLabelLn(sb, "type", type, indent + 1);
        DebugUtil.debugDumpWithLabelLn(sb, "query", query, indent + 1);
        DebugUtil.debugDumpWithLabelLn(sb, "searchOptions", searchOptions, indent + 1);
        DebugUtil.debugDumpWithLabel(sb, "useRepository", useRepository, indent + 1);
        return sb.toString();
    }

    @SuppressWarnings({ "MethodDoesntCallSuperMethod" })
    @Override
    public SearchSpecification<C> clone() {
        return new SearchSpecification<>(this);
    }

    public static <T extends ObjectType> SearchSpecification<T> fromTypedQuery(TypedObjectQuery<T> typedQuery) {
        return new SearchSpecification<>(typedQuery.getObjectClass(), typedQuery.getObjectQuery(), null, false);

    }
}
