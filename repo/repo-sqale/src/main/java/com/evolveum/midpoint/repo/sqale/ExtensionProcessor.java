/*
 * Copyright (C) 2010-2022 Evolveum and contributors
 *
 * This work is dual-licensed under the Apache License 2.0
 * and European Union Public License. See LICENSE file for details.
 */
package com.evolveum.midpoint.repo.sqale;

import java.util.*;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.namespace.QName;

import com.evolveum.prism.xml.ns._public.types_3.ProtectedDataType;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import com.evolveum.midpoint.prism.*;
import com.evolveum.midpoint.prism.polystring.PolyString;
import com.evolveum.midpoint.repo.sqale.jsonb.Jsonb;
import com.evolveum.midpoint.repo.sqale.jsonb.JsonbUtils;
import com.evolveum.midpoint.repo.sqale.qmodel.ext.MExtItem;
import com.evolveum.midpoint.repo.sqale.qmodel.ext.MExtItem.Key;
import com.evolveum.midpoint.repo.sqale.qmodel.ext.MExtItemCardinality;
import com.evolveum.midpoint.repo.sqale.qmodel.ext.MExtItemHolderType;
import com.evolveum.midpoint.repo.sqale.qmodel.object.MObjectType;
import com.evolveum.midpoint.util.QNameUtil;
import com.evolveum.midpoint.util.exception.SchemaException;
import com.evolveum.midpoint.util.exception.SystemException;

import static com.evolveum.midpoint.repo.sqale.jsonb.JsonbUtils.toRealValue;

public class ExtensionProcessor {

    private final SqaleRepoContext repositoryContext;

    public ExtensionProcessor(SqaleRepoContext repositoryContext) {
        this.repositoryContext = repositoryContext;
    }

    public Jsonb processExtensions(
            @NotNull Containerable extContainer, MExtItemHolderType holderType) {
        Map<String, Object> extMap = new LinkedHashMap<>();
        PrismContainerValue<?> prismContainerValue = extContainer.asPrismContainerValue();
        for (Item<?, ?> item : prismContainerValue.getItems()) {
            try {
                Objects.requireNonNull(item, "Object for converting must not be null.");
                ItemDefinition<?> extDef = item.getDefinition();
                if (extDef == null) {
                    continue; // item does not have definition, skipping
                }

                ExtItemInfo extItemInfo = findExtensionItem(extDef, holderType);
                if (extItemInfo == null) {
                    continue; // not-indexed, skipping this item
                }

                Object value = extItemValue(item, extItemInfo);
                if (value != null) {
                    extMap.put(extItemInfo.getId(), value);
                }
                // We may need to add also single value index, if definition is dynamic;
                // see additionalSingleValueIndexNeeded() javadoc for more information.
                if (additionalSingleValueIndexNeeded(item, extItemInfo)) {
                    addSingleValueIndex(extMap, item, holderType);
                }

            } catch (RuntimeException e) {
                // If anything happens (like NPE in Map.of) we want to capture the "bad" item.
                throw new SystemException(
                        "Exception when translating extension item " + item, e);
            }
        }

        return Jsonb.fromMap(extMap);
    }

    /**
     * Checks if additional single value index is needed
     *
     * If item contains single value and item definition is dynamic (e.g. generated by parser),
     * we do not know if known definition is single or multi value. During search definition
     * is provided by provisioning - and contains multiplicity, this allows for both indexes
     * (scalar and array) to be available for such search.
     *
     * Dynamic definition (instead of real definition) is usually present during direct manipulation
     * of objects via repository APIs and not model APIs. Existence of both indexes in unknown
     * states allows for search to work properly, once definition is known to search invoker.
     *
     * @param item Item to be added
     * @param extItemInfo Originally determined item definition
     * @return true if we also need to add single value index
     */
    private boolean additionalSingleValueIndexNeeded(Item<?, ?> item, ExtItemInfo extItemInfo) {
        return item.size() == 1
                && MExtItemCardinality.ARRAY.equals(extItemInfo.item.cardinality)
                && item.getDefinition().isDynamic();
    }

    private void addSingleValueIndex(Map<String, Object> extMap, Item<?, ?> item, MExtItemHolderType holderType) {
        ItemDefinition<?> extDef = item.getDefinition();
        Key singleValueKey = MExtItem.keyFrom(extDef, holderType, MExtItemCardinality.SCALAR);
        MExtItem singleValueExt = repositoryContext.resolveExtensionItem(singleValueKey);
        ExtItemInfo singleInfo = extItemInfo(singleValueExt, extDef);
        Object singleValue = extItemValue(item, singleInfo);
        extMap.put(singleInfo.getId(), singleValue);
    }

    /** Returns ext item definition or null if the item is not indexed and should be skipped. */
    @Nullable
    public ExtensionProcessor.ExtItemInfo findExtensionItem(
            @NotNull ItemDefinition<?> definition, MExtItemHolderType holderType) {
        MExtItem extItem = resolveExtensionItem(definition, holderType);
        if (extItem == null) {
            return null; // not-indexed, returning null
        }

        return extItemInfo(extItem, definition);
    }

    private ExtensionProcessor.ExtItemInfo extItemInfo(MExtItem extItem, ItemDefinition<?> definition) {
        ExtItemInfo info = new ExtItemInfo();
        info.item = extItem;
        if (definition instanceof PrismReferenceDefinition) {
            info.defaultRefTargetType = ((PrismReferenceDefinition) definition).getTargetTypeName();
        }
        return info;
    }

    @Nullable
    public Object extItemValue(Item<?, ?> item, ExtItemInfo extItemInfo) {
        MExtItem extItem = extItemInfo.item;
        if (extItem.cardinality == MExtItemCardinality.ARRAY) {
            List<Object> vals = new ArrayList<>();
            for (Object realValue : item.getRealValues()) {
                vals.add(convertExtItemValue(realValue, extItemInfo));
            }
            return vals;
        } else {
            return convertExtItemValue(item.getRealValue(), extItemInfo);
        }
    }

    @Nullable
    private Object convertExtItemValue(Object realValue, ExtItemInfo extItemInfo) {
        if (realValue == null) {
            return null;
        }
        checkRealValueType(realValue, extItemInfo.item);
        if (realValue instanceof String
                || realValue instanceof Number
                || realValue instanceof Boolean) {
            return realValue;
        }
        if (realValue instanceof byte[] bytes) {
            return JsonbUtils.bytesToBase64(bytes);
        }

        if (realValue instanceof PolyString) {
            PolyString poly = (PolyString) realValue;
            return JsonbUtils.polyStringToMap(poly);
        }

        if (realValue instanceof Referencable) {
            Referencable ref = (Referencable) realValue;
            // we always want to store the type for consistent search results
            QName targetType = ref.getType();
            if (targetType == null) {
                targetType = extItemInfo.defaultRefTargetType;
            }
            if (targetType == null) {
                throw new IllegalArgumentException(
                        "Reference without target type can't be stored: " + ref);
            }
            return Map.of(JsonbUtils.JSONB_REF_TARGET_OID_KEY, ref.getOid(),
                    JsonbUtils.JSONB_REF_TARGET_TYPE_KEY, MObjectType.fromTypeQName(targetType),
                    JsonbUtils.JSONB_REF_RELATION_KEY, repositoryContext.processCacheableRelation(ref.getRelation()));
        }

        if (realValue instanceof Enum) {
            return realValue.toString();
        }

        if (realValue instanceof XMLGregorianCalendar) {
            // XMLGregorianCalendar stores only millis, but we cut it to 3 fraction digits
            // to make the behavior explicit and consistent.
            return ExtUtils.extensionDateTime((XMLGregorianCalendar) realValue);
        }

        if (realValue instanceof ProtectedDataType<?> data) {
            return JsonbUtils.protectedDataToMap(data);
        }

        throw new IllegalArgumentException(
                "Unsupported type '" + realValue.getClass().getName() + "' for value '" + realValue + "'.");
    }



    private void checkRealValueType(Object realValue, MExtItem extItemInfo) {
        Class<?> realValueType = ExtUtils.getRealValueClass(extItemInfo.valueType);
        if (realValueType != null && !realValueType.isAssignableFrom(realValue.getClass())) {
            throw new IllegalArgumentException("Incorrect real value type '"
                    + realValue.getClass().getName() + "' for item " + extItemInfo.itemName);
        }
    }

    /**
     * Finds extension item for the provided definition and holder type.
     * Returns null if the item is not indexed.
     */
    public MExtItem resolveExtensionItem(
            @NotNull ItemDefinition<?> definition, MExtItemHolderType holderType) {
        if (definition instanceof PrismContainerDefinition<?>) {
            // Skip containers for now
            return null;
        }
        if (definition instanceof PrismPropertyDefinition<?> prismPropertyDefinition) {
            // Note that we don't want to turn off indexing for attributes, because they are stored in indexed form only
            // (on native repository). The storage of attributes has to be turned off by disabling caching for them completely.
            // Indexed=false can occur for attributes with storage = NOT_INDEXED, which is used for generic repo - for attributes
            // that should be put into XML but cannot be stored in m_object_ext_xxx tables (e.g. because they are too large).
            if (holderType == MExtItemHolderType.EXTENSION && Boolean.FALSE.equals(definition.isIndexed())) {
                return null;
            }
            // enum is recognized by having allowed values
            if (!ExtUtils.isRegisteredType(definition.getTypeName())
                    && !ExtUtils.isEnumDefinition(prismPropertyDefinition)) {
                return null;
            }
        } else if (!(definition instanceof PrismReferenceDefinition)) {
            throw new UnsupportedOperationException("Unknown definition type '" + definition
                    + "', can't say if '" + definition.getItemName() + "' is indexed or not.");
        } // else it's reference which is indexed implicitly

        return repositoryContext.resolveExtensionItem(MExtItem.keyFrom(definition, holderType));
    }

    public void extensionsToContainer(Map<String, Object> attributes, Containerable container) throws SchemaException {
        PrismContainerValue<?> pcv = container.asPrismContainerValue();
        for (Map.Entry<String, Object> attribute : attributes.entrySet()) {
            MExtItem mapping = Objects.requireNonNull(
                    repositoryContext.getExtensionItem(Integer.valueOf(attribute.getKey())));
            QName itemName = QNameUtil.uriToQName(mapping.itemName);
            ItemDefinition<?> definition = ExtUtils.createDefinition(itemName, mapping, true);

            if (definition instanceof PrismPropertyDefinition<?> propertyDefinition) {
                var item = pcv.findOrCreateProperty(propertyDefinition);
                // In theory single-value can overwrite multi-value in the same item (with the same name) when both
                // variants are written in JSONB - but both variants are only written when single value is present
                // and definition is not provided. If the multi-value is changed later the single-value variant
                // is removed from JSONB (see code in ExtensionItemDeltaProcessor).
                // Do not overwrite values from full object
                if (item.isEmpty()) {
                    switch (mapping.cardinality) {
                        case SCALAR:
                            item.setRealValue(toRealValue(attribute.getValue(), definition.getTypeName(), repositoryContext));
                            break;
                        case ARRAY:
                            List<?> value = (List<?>) attribute.getValue();
                            item.setRealValues(value.stream().map(v -> toRealValue(v, definition.getTypeName(), repositoryContext)).toArray());
                            break;
                        default:
                            throw new IllegalStateException("");
                    }
                } else {
                    item.getValues();
                }
                if (item.isIncomplete() && (item.getDefinition() == null || !item.getDefinition().isIndexOnly())) {
                    // Item was not fully serialized / probably indexOnly item.
                    //noinspection unchecked
                    item.applyDefinition((PrismPropertyDefinition<Object>) definition);
                }
                item.setIncomplete(false);
            }
        }
    }

    /** Contains ext item from catalog and additional info needed for processing. */
    public static class ExtItemInfo {
        public MExtItem item;
        public QName defaultRefTargetType;

        public String getId() {
            return item.id.toString();
        }
    }
}
