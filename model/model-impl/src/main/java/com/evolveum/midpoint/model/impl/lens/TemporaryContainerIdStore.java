/*
 * Copyright (C) 2010-2022 Evolveum and contributors
 *
 * This work is dual-licensed under the Apache License 2.0
 * and European Union Public License. See LICENSE file for details.
 */

package com.evolveum.midpoint.model.impl.lens;

import com.evolveum.midpoint.prism.*;
import com.evolveum.midpoint.prism.delta.ItemDelta;
import com.evolveum.midpoint.prism.delta.ObjectDelta;
import com.evolveum.midpoint.prism.path.ItemPath;
import com.evolveum.midpoint.prism.path.PathSet;
import com.evolveum.midpoint.util.exception.SchemaException;
import com.evolveum.midpoint.util.logging.Trace;
import com.evolveum.midpoint.util.logging.TraceManager;
import com.evolveum.midpoint.xml.ns._public.common.common_3.ObjectType;

import org.jetbrains.annotations.NotNull;

import java.io.Serializable;
import java.util.*;

import static com.evolveum.midpoint.util.MiscUtil.emptyIfNull;

/**
 * Generates and keeps temporary IDs for PCVs that are to be created and modified during clockwork processing.
 * These IDs are from a special range (currently, negative numbers are used) and they are resolved when the delta
 * is going to be executed.
 *
 * This mechanism is used when focus identities are processed. We need to pretend working with PCVs that really don't exist (yet)
 * by issuing "modify" deltas against their components. At the end of the day, we will replace these modify deltas with a single
 * "add value" delta.
 *
 * Scenario (for object MODIFY delta):
 *
 * . The client creates a new PCV with a temporary ID (provided by {@link #getTemporaryId(ItemPath)}) method.
 * . Afterwards, a set of `modify` deltas are issued against this PCV (starting with temporary ID).
 * . When resolving (see {@link #resolveTemporaryIds(ObjectDelta)}), all these `modify` deltas are merged with into the PCV,
 * and replaced by a single `add` delta, with no mention of temporary ID. The ID will be generated by the repository.
 *
 * For object ADD delta, we simply delete any temporary IDs.
 *
 * @see AssignmentIdStore
 */
class TemporaryContainerIdStore<O extends ObjectType> implements Serializable {

    private static final Trace LOGGER = TraceManager.getTrace(TemporaryContainerIdStore.class);

    /** Paths for which temporary IDs have been provided. */
    private final PathSet pathsAffected = new PathSet();

    /** Sequence of the temporary IDs. */
    private int nextId = -1;

    /** Map of ID -> PCV being added (values are filled-in when resolving IDs). */
    private final Map<Long, PrismContainerValue<?>> resolutionMap = new HashMap<>();

    int getTemporaryId(@NotNull ItemPath itemPath) {
        pathsAffected.add(itemPath);
        int id = nextId--;
        LOGGER.trace("Providing temporary ID {} for '{}'", id, itemPath);
        resolutionMap.put((long) id, null);
        return id;
    }

    boolean resolveTemporaryIds(ObjectDelta<O> objectDelta) throws SchemaException {
        if (pathsAffected.isEmpty()) {
            LOGGER.trace("No paths affected? This shouldn't occur, as this store is created only when a temporary ID is needed.");
            return false;
        }
        if (objectDelta == null) {
            LOGGER.trace("No delta");
            return false;
        }
        if (objectDelta.isAdd()) {
            LOGGER.trace("Resolving temporary IDs for ADD delta: {}", objectDelta);
            for (ItemPath itemPath : pathsAffected) {
                resolveForAddition(itemPath, objectDelta.getObjectToAdd());
            }
        } else if (objectDelta.isModify()) {
            LOGGER.trace("Resolving temporary IDs for MODIFY delta: {}", objectDelta);
            for (ItemPath itemPath : pathsAffected) {
                resolveForModification(itemPath, objectDelta);
            }
        } else {
            LOGGER.trace("Nothing to do for DELETE delta: {}", objectDelta);
        }
        return true;
    }

    private void resolveForAddition(ItemPath itemPath, PrismObject<O> object) {
        if (object == null) {
            return; // shouldn't occur
        }
        Item<?, ?> item = object.findItem(itemPath);
        if (item instanceof PrismContainer) {
            for (PrismContainerValue<?> pcv : ((PrismContainer<?>) item).getValues()) {
                Long id = pcv.getId();
                if (resolutionMap.containsKey(id)) {
                    LOGGER.trace("Removing temporary ID {} from its PCV", id);
                    pcv.setId(null);
                }
            }
        }
    }

    private void resolveForModification(ItemPath itemPath, ObjectDelta<O> objectDelta) throws SchemaException {
        LOGGER.trace("Resolving temporary ID(s) for {}", itemPath);
        for (ItemDelta<?, ?> modification : new ArrayList<>(objectDelta.getModifications())) {
            ItemPath modificationPath = modification.getPath();
            if (modificationPath.startsWith(itemPath)) {
                ItemPath remainder = modificationPath.remainder(itemPath);
                if (remainder.isEmpty()) {
                    processPcvAdd(itemPath, modification);
                } else {
                    processPcvModify(remainder, objectDelta, modification);
                }
            }
        }
    }

    private void processPcvAdd(ItemPath itemPath, ItemDelta<?, ?> modification) {
        if (doValuesContainTemporaryId(modification.getValuesToReplace())) {
            LOGGER.error("REPLACE delta with temporary ID(s):\n{}", modification.debugDump(1));
            throw new UnsupportedOperationException("Temporary IDs are not supported for REPLACE deltas");
        }
        if (doValuesContainTemporaryId(modification.getValuesToDelete())) {
            LOGGER.error("DELETE delta with temporary ID(s):\n{}", modification.debugDump(1));
            throw new UnsupportedOperationException("Temporary IDs are not supported for DELETE deltas");
        }
        for (PrismValue valueToAdd : emptyIfNull(modification.getValuesToAdd())) {
            if (!(valueToAdd instanceof PrismContainerValue<?> pcvToAdd)) {
                throw new IllegalStateException(
                        String.format("Value to add for '%s' is not a PCV: '%s'", itemPath, valueToAdd));
            }
            Long id = pcvToAdd.getId();
            if (id != null && resolutionMap.containsKey(id)) {
                LOGGER.trace("Found value to add (with a temporary ID that we are going to clear): {}", pcvToAdd);
                if (resolutionMap.put(id, pcvToAdd) != null) {
                    throw new IllegalStateException(
                            String.format("Attempting to add %s twice?", pcvToAdd));
                }
                pcvToAdd.setId(null);
            }
        }
    }

    private void processPcvModify(ItemPath remainder, ObjectDelta<O> objectDelta, ItemDelta<?, ?> modification)
            throws SchemaException {
        Long firstId = remainder.firstToIdOrNull();
        PrismContainerValue<?> pcvBeingAdded = resolutionMap.get(firstId);
        if (pcvBeingAdded != null) {
            LOGGER.trace("Found modification related to a PCV to add: {}", modification);
            ItemPath rest = remainder.rest();
            //noinspection unchecked
            Item<?, ?> subItem = pcvBeingAdded.findOrCreateItem(
                    rest, modification.getItemClass(), modification.getDefinition());
            if (subItem == null) {
                throw new SchemaException(
                        String.format("Couldn't create sub item for '%s' in '%s'", rest, pcvBeingAdded));
            }
            modification.applyToMatchingPath(subItem);
            if (!objectDelta.deleteModification(modification)) {
                LOGGER.warn("Couldn't delete modification referencing a PCV with temporary ID: {}", modification);
            }
        }
    }

    private boolean doValuesContainTemporaryId(Collection<?> values) {
        for (Object value : emptyIfNull(values)) {
            if (value instanceof PrismContainerValue<?> pcv && resolutionMap.containsKey(pcv.getId())) {
                return true;
            }
        }
        return false;
    }
}
