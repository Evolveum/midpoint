---
midpoint-feature: dashboard
doc-type: config
---

= Create dashboards in midPoint
:page-nav-title: Configure dashboards
:page-wiki-name: Dashboard configuration
:page-wiki-id: 36569129
:page-wiki-metadata-create-user: lskublik
:page-wiki-metadata-create-date: 2019-08-06T13:26:25.499+02:00
:page-wiki-metadata-modify-user: katkav
:page-wiki-metadata-modify-date: 2020-12-10T12:36:51.667+01:00
:page-toc: top
:page-keywords: [ 'dashboard', 'dashboards', 'configuration' ]
:search-alias: "dashboard configuration"
:page-upkeep-status: yellow
:page-upkeep-note: check TODO's after sampleRef is fully in prod remove links

This article guides you through the steps required to configure dashboards.
Start with a simple dashboard showing one metric, such as number of active users, then continue adding more advanced pieces, such as percentage of failed resources or accounts violating segregation of duties.

From the data update perspective, dashboard widgets can be xref:../#async-dashboards-and-report[synchronous or asynchronous].
In this guide, you first create a simple synchronous widget.
After that, you will add an asynchronous widget to the dashboard.

[TIP]
====
We recommend using link:https://www.jetbrains.com/idea/[IntelliJ IDEA] with the xref:/midpoint/tools/studio/[midPoint Studio] plugin.
Engineering midPoint with Studio is definitely much easier.
====

== Quick guides to create and deploy dashboards

Before we dive into details, here is a TL;DR version of this article.
The points below summarize the steps to take when deploying dashboards.

=== How to deploy standard dashboards

. Prepare and xref:/midpoint/tools/studio/usage/index.adoc#uploading-midpoint-objects[upload] an object collection with an object filter definition.
. Prepare and upload a dashboard.
. Add a `<configurableUserDashboard>` element to `SystemConfiguration` and upload the configuration.
. Check the configuration:
.. Refresh the GUI (you may need to log out and back in) to apply the system configuration changes.
.. Go to [.nowrap]#icon:tachometer-akt[] *Dashboards*# to see your new dashboard.

=== How to deploy dashboards with asynchronous widgets

. Prepare and xref:/midpoint/tools/studio/usage/index.adoc#uploading-midpoint-objects[upload] an object collection with an object filter definition.
. Prepare and upload a dashboard.
. Prepare and upload a dashboard report.
. Prepare and upload a report task.
. Add a `<configurableUserDashboard>` element to `SystemConfiguration` and upload the configuration.
. Check the configuration:
.. Refresh the GUI (you may need to log out and back in) to apply the system configuration changes.
.. Go to [.nowrap]#icon:tachometer-akt[] *Dashboards*# to see your new dashboard.
    The asynchronous widget cannot show data yet.
.. Run the report task or wait until its scheduled run finishes.
.. Go to [.nowrap]#icon:tachometer-akt[] *Dashboards*# again.
    The asynchronous widget should now display correct data.

When you upload dashboard with asynchronous widgets, it will display an _Unknown_ value until the report task runs for the first time and saves the computed data to the dashboard widgets.

[TIP]
====
You can get inspiration in the midPoint configuration samples in the link:https://github.com/Evolveum/midpoint-samples/tree/master/samples/dashboard/howto[samples/dashboard/howto] directory.

In the directory, you can find examples of:

* `collection-enabled-users.xml`: Object collection filtering enabled users.
* `collection-disabled-users.xml`: Object collection filtering disabled users.
* `dashboard-howto-example.xml`: Dashboard definition.
* `report-dashboard-howto-example.xml`: Dashboard report used to update the asynchronous dashboard widgets.
* `task-report-dashboard-howto-example.xml`: Dashboard task used to run the report.
====

== Create your custom dashboard

To create a dashboard, you need to create a dashboard object with an OID, name, label, and widgets.
The name and label are used for the graphical user interface.

[source,xml]
----
<dashboard oid="8f9f3d5f-a890-452b-8d2b-57b8644c1f04">
     <name>system-status-dashboard</name>
     <display>
         <label>Number of active users</label>
     </display>
     <widget>
        <!--1-->
     </widget>
     <widget>
        <!--2-->
     </widget>
</dashboard>
----
<1> The widget code from the link:#simple-widget[section on a simple widget] goes here.
<2> The widget code from the link:#async-widget[section on an asynchronous widget] goes here.

The dashboard with two widgets is ready but its widgets are not.
Now is the time to create them.

[[simple-widget]]
=== Create a simple widget for the dashboard

Widgets are not separate objects, they go directly into their parent dashboard object.
The first widget we create here is simple, the data it shows are calculated every time a user loads the screen with the dashboard.
You will see how to create an asynchronous widget in the example for the second widget below.

The first simple widget shows the number of users that are active; for example, active employees as opposed to those on long-term leave.
The widget itself does not count the users.
That is what the object collection is for (see the `collectionRef` element below).

[source,xml]
----
<widget>
    <identifier>active-users</identifier>
    <display>
        <label>Number of active users</label>
        <color>#229911</color>
        <icon>
            <cssClass>fa fa-user</cssClass>
        </icon>
    </display>
    <data>
        <sourceType>objectCollection</sourceType>
        <collection>
            <collectionRef
                oid="0ac5f62a-1d0c-4b0c-afbf-d19bfb1f6112" <!--1-->
                type="ObjectCollectionType"
            />
        </collection>
    </data>
    <presentation>
        <dataField>
            <fieldType>value</fieldType>
            <expression>
                <proportional>
                    <style>value-only</style>
                </proportional>
            </expression>
        </dataField>
        <dataField>
            <fieldType>unit</fieldType>
            <expression>
                <value>active</value>
            </expression>
        </dataField>
    </presentation>
</widget>
----
<1> The object collection OID from the link:#create-collection[section below] goes here.

The dashboard now has one widget.
However, it still has no data to show, because we do not have the object collection yet.

[[create-collection]]
=== Define object collection to count objects of interest

Object collections, as their name suggests, _collect_ or enumerate objects based on a query you define.
Object collections are standalone midPoint objects.

To go with the example of counting active users we use here, create a collection that enumerates objects of the `UserType` type (i.e., users) for which the `activation/effectiveStatus` equals to `enabled`.

[source,xml]
----
<objectCollection oid="0ac5f62a-1d0c-4b0c-afbf-d19bfb1f6112">
    <name>All enabled users</name>
    <type>UserType</type>
    <filter>
        <q:text>activation/effectiveStatus = "enabled"</q:text>
    </filter>
</objectCollection>
----

And this is it.
Add the OID of the collection above to the `collectionRef` in the widget, move the widget code to the dashboard object, and upload both the collection and the dashboard objects to your midPoint instance.

The only step that remains is to display the dashboard in the midPoint graphical user interface.

=== Add the dashboard to the main menu

To have the new dashboard displayed in the main menu in midPoint, you need to add it to the system configuration:

[source,xml]
----
<systemConfiguration ... >
    ...
    <adminGuiConfiguration>
        <configurableUserDashboard id="999"> <!--1-->
            <identifier>enabled-users-dashboard</identifier>
            <configurableDashboardRef
                oid="8f9f3d5f-a890-452b-8d2b-57b8644c1f04" <!--2-->
                relation="org:default"
                type="c:DashboardType"
            >
            </configurableDashboardRef>
        </configurableUserDashboard>
        <!--3-->
    </adminGuiConfiguration>
    ...
</systemConfiguration>
----
<1> Unique integer ID.
<2> The OID of your dashboard goes here.
<3> More `configurableUserDashboard` elements can follow here, one for each dashboard.

Now, you can refresh the GUI (you may need to log out and back in) and go to [.nowrap]#icon:tachometer-akt[] *Dashboards*# to see your new dashboard.

image::first-dashboard-active-users.webp["MidPoint GUI with the dashboards menu open and a dashboard with active users shown", title="The dashboards section featuring the custom dashboard from the configuration example provided here."]

[[async-widget]]
== Create asynchronous widget to reduce system load

Simple widgets like the one above force midPoint to compute the data every time a user loads the dashboard screen.
If you have a lot of users or a lot of computationally complex dashboards, this may needlessly overload the infrastructure your midPoint instance runs on.
And that is where asynchronous widgets come in handy.

An asynchronous widget uses a task to recompute the data at an interval of your choosing and holds the result in the widget object.
You can use the same object collection as you do with the synchronous widget above.

[NOTE]
====
Report tasks for asynchronous dashboard update are not to be confused with
xref:/midpoint/reference/tasks/synchronization-tasks/asynchronous-update[asynchronous update tasks] which are used for updating data from resources.
====

=== Configure your widget for asynchronous loading

To configure a widget as asynchronous, you need to adjust the widget data source and create two new pieces of configuration:

* A report which takes the dashboard configuration, triggers the data computation, and saves the results into the dashboard widget objects.
    ** Note that you always compute the data for all the widgets in the dashboard the report references.
* A report task which runs the report at scheduled intervals to refresh the data.

First, change the widget configuration by adding the `displaySourceType` element so that the report can save the computed data in the widget object:

[source,xml]
----
<widget>
    <identifier>active-users</identifier>
    <display>
        <label>Number of active users</label>
        <color>#883399</color>
        <icon>
            <cssClass>fa fa-user</cssClass>
        </icon>
    </display>
    <data>
        <sourceType>objectCollection</sourceType>
        <displaySourceType>widgetData</displaySourceType> <!--1-->
        <collection>
            <collectionRef
                oid="0ac5f62a-1d0c-4b0c-afbf-d19bfb1f6112" <!--2-->
                type="ObjectCollectionType"
            />
        </collection>
    </data>
    <presentation>
        <dataField>
            <fieldType>value</fieldType>
            <expression>
                <proportional>
                    <style>value-only</style>
                </proportional>
            </expression>
        </dataField>
        <dataField>
            <fieldType>unit</fieldType>
            <expression>
                <value>active</value>
            </expression>
        </dataField>
    </presentation>
</widget>
----
<1> Enable saving data into the widget object
<2> The object collection OID goes here.

=== Create a dashboard report connected to your dashboard

Secondly, you need a dashboard report that "runs" the dashboard as if a user has visited it and makes midPoint compute the data in the dashboard.

[NOTE]
====
If you display the dashboard with an asynchronous widget before you create and run the report for the first time,
the widget will show _Unknown_ instead of a meaningful value because midPoint has not yet computed the data to show.
====

See xref:/midpoint/reference/misc/reports/configuration/dashboard-report/[] for instructions on creating a dashboard report.

When configuring the report, use your dashboard as the configuration basis of the report.
After you create the report, you can run it manually to compute the data and verify your configuration.

=== Create a scheduled recurring task to refresh dashboard data regularly

To have the data on the dashboard refreshed regularly, you need a recurring task.

See xref:/midpoint/reference/misc/reports/configuration/report-task-definition/#export-report[] for instructions on creating an export report task.

When configuring the task, you need to use the _report export_ activity and use the OID of the dashboard report you want the task to run.
In most cases, it makes sense to schedule this task to run in regular intervals in order to have the data in the dashboard updated automatically.

== Dashboard widget configuration attributes

The widget element contains three configuration attributes: `display`,`data`, and `presentation`.

=== Display attribute

The `display` attribute contains configuration of the widget visual side in the GUI.

[%autowidth]
|===
| Name | Type | Description

| `label`
| String
| Displayed name of Widget.


| `color`
| String
| Default color of background for widget.


| `icon/cssClass`
| String
| CssClass for widget icon for example "fa fa-user".


| `cssStyle`
| String
| CssStyle for widget for example "color: #444 !important" for change of font color.


|===

=== Data attribute

The `data` attribute represents the data source that the widget displays.
There are two kinds of data in midpoint:

* for _objectCollection_
* for _objectType_

[%autowidth]
|===
| Name | Type | Description

| `sourceType`
| `DashboardWidgetSourceTypeType`
| Type of widget content data source.
Specify type of input data, which midPoint uses for generating a message showed in the widget.
This is an enumeration type and possible values are  _objectCollection_ (content of widget is based on object collection), _auditSearch_ (content of the widget will be based on data from object collection with filter for audit records) and _object_ (content of the widget will be based on data from a single object). We describe this using `sourceType` and `displaySourceType` in the example under table.

| `displaySourceType`
| `DashboardWidgetSourceTypeType`
| This attribute is an identifier that overrides sourceType. We can use it for asynchronous widgets.
This element is used only for number messages showed in a widget in the GUI. The widget in the GUI might contain a link for a redirect to a details page and the used sourceType. We describe the usage of `sourceType` and `displaySourceType` in an example under the table.


| `collection`
| `CollectionRefSpecificationType`
| Specification of an explicit or implicit object collection that will be used as data source for the view.
Contains variable _collectionRef,_ which is a reference to the object collection which is displayed in the widget.


| `objectRef`
| `ObjectReferenceType`
| Specification of a single object as a widget data source.

| `storedData`
| `String`
| Specification of a string data as a widget data source. This data can be stored by a report task. A Widget will leverage it by the usage of an asynchronous widget.

|===

===== Using sourceType and displaySourceType

When we configure a simple widget, we can set the `sourceType` to either `objectCollection`, `auditSearch` or `object`.

The `displaySourceType` is important for asynchronous widgets.
In the case of async widgets we set `widgetData` as `displaySourceType` and as `sourceType` we will use `objectCollection`.
This will mean that the widget will show stored data from the attribute `storedData` but when you click the widget the redirection for object details will use the `sourceType`. We can't forget, that `sourceType` will also use by Export report task for generation `storedData`.

When we use an `objectCollection` or `auditSearch` as source, midPoint will need a reference to the object collection which contains a filter for the reported data.

The following is and example of widget data source for object collection:

[source,xml]
----
<widget>
    ...
    <data>
        <sourceType>objectCollection</sourceType>
        <collection>
            <collectionRef oid="15de186e-1d8c-11e9-a469-8f5d9cfc0259" type="c:ObjectCollectionType"/>
        </collection>
    </data>
</widget>
----

Another option is to define a specific `object` as source, in this case part of the configuration is a reference to the object, which will be used as a source.
The configuration will contain a path to the attribute, which will be presented in the widget.

Example of widget data source for object type:

[source,xml]
----
<widget>
    ...
    <data>
        <sourceType>object</sourceType>
        <objectRef oid="00000000-0000-0000-0000-000000000005" type="c:TaskType"/>
    </data>
</widget>
----

A widget in the GUI with `object` as source. In this case it is the Cleanup task with the path set to the `state` attribute:

image::object.png[]

In the case when we want to set up an asynchronous widget, we can use an `objectCollection`, `auditSearch` or `object` as source, but additionally we have to use the `widgetData` attribute value for the `displaySourceType` attribute.

Example of widget data source for widget data (asynchronous widget):

[source,xml]
----
<widget>
    ...
    <data>
        <sourceType>objectCollection</sourceType>
        <displaySourceType>widgetData</displaySourceType>
        <collection>
            <collectionRef oid="15de186e-1d8c-11e9-a469-8f5d9cfc0259" type="c:ObjectCollectionType"/>
        </collection>
        <storedData>25/25 runnable</storedData>
    </data>
</widget>
----

=== Presentation of Widget Data

There is and container attribute which is used to define how will be data presented.
The name of the attribute is `presentation`.

We define four basic kind of presentation:

* percentage (50%)

image::percentage.png[]

* separated with slash (5/10)

image::slash.png[]

* separated with "of" (5 of 10)

image::of.png[]

* only value (5)

image::only-value.png[]

Presentation contains three attributes: `dataField`, `variation` and `view`.


===== The Widget Data Field

The attribute `dataField`, describes the properties of a specific widget data field.
Note that the order of dataField elements is NOT significant.
The field order is given by specific presentation style.

Attributes for `dataField`:

[%autowidth]
|===
| Name | Type | Description

| `fieldType`
| DashboardWidgetDataFieldTypeType
| Type of the field.
Currently, we support the following values `value` and `unit` of the `fieldType` attribute.
`value` is the actual value of the data which is being displayed i.e. some number.
`unit` defines the unit of the value.
For example in message '5/9 up', where '5/9' is generated via configuration for `value` and 'up' is generated via configuration for `unit`.


| `expression`
| ExpressionType
| Expression that produces value to display in the widget.


|===

For the `fieldType` attribute, when set to  `value`, we define a special type of expression, in it, we need to define the attribute `proportional` with an attribute `style`.
The attribute `style` is a enumeration type with values `percentage` (for example 50%), `value-slash-domain` (for example 5/10), `value-of-domain` (for example 5 of 10) and `value-only` (for example 5).

===== Variation of Widget Data

Next presentation attribute is `variation`. Conditional variation in the way how the widget is displayed.
Variations may change colors or icons of the widget based on a condition.
Attributes for `variation`:

[%autowidth]
|===
| Name | Type | Description

| `condition`
| ExpressionType
| Condition for the variation.
The variation will be active if the condition evaluates to true.


| `display`
| DisplayType
| Display properties to apply in case that the condition is true.
Those display properties specify only those presentation aspects that are different from the usual presentation.
This is supposed to be merged with the primary display properties of the widget.
E.g. if the variation only changes widget color, only color needs to be specified here.
Icon and other styles are taken from the primary widget display properties.


|===

`condition` can get four variables:

[%autowidth]
|===
| Name | Type | Description | sourceType in data of widget

| `proportional`
| IntegerStatType
| Integer stat (statistic) entry.
This entry contains stat value, together with domain value.
| objectCollection, auditSearch


| `policySituations`
| Collection<String>
| Collection of policy situations.
| objectCollection


| `object`
| base on displayed object in widget
| Processed object.
| object


| `storedData`
| String
| Stored data from widget.
| widgetData


|===

// TODO no example, add ??
===== View

Last variable of the presentation container is `view`, this variable is also processed in case we create reports.
The main reason to configure a view would be the customization of the reported or presented object collection on which we based the dashboard widget.
The widget object collection can be accessed via the IU *"More info"* button.

//TODO check after sampleRef is fully in prod
.*Example of `presentation`*:
[%collapsible]
====
[source,xml]
----
<widget>
    ...
    <presentation>
        <dataField>
            <fieldType>value</fieldType>
            <expression>
                <proportional xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="c:ProportionalExpressionEvaluatorType">
                    <style>percentage</style>
                </proportional>
            </expression>
        </dataField>
        <dataField>
            <fieldType>unit</fieldType>
            <expression>
                <value>up</value>
            </expression>
        </dataField>
        <variation>
            <condition>
                <script xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="c:ScriptExpressionEvaluatorType">
                    <code>
                        policySituations.contains("#resourceHealthDanger")
                    </code>
                </script>
            </condition>
            <display>
                <color>#dd4b39</color>
            </display>
        </variation>
    </presentation>
</widget>
----
====

=== Configuration details for object collections

You can see basic configuration for objectCollection on xref:/midpoint/reference/admin-gui/collections-views/configuration/#object-collection[Object Collection].
For dashboard, we can use policyRule with policyTreshold to define some policySituation.
Example of object collection for resource, which have status set to "UP":

//TODO check after sampleRef is fully in prod
.*Example Object Collection*
[%collapsible]
====
link:https://github.com/Evolveum/midpoint-samples/blob/master/samples/dashboard/object-collection-resource-up.xml[Git]

sampleRef::samples/dashboard/object-collection-resource-up.xml[]
====

Variable _domain_ is a set of object that represents "all the objects" used in this collection.
For example collection of "up resources" will have a domain of "all resources".
The domain is filtered out via the _filter_ to contain only the specific set of objects which we need.

In this example we use _policyRule_ with _policySituation_, which we can leverage in the variation of widget presentation.
When policyTreshold is met policySituation from policyRule triggers the widget variation.
The _policyThreshold_ has two important variables for us, lowWaterMark and highWaterMark.

lowWaterMark is lower bound of the threshold. Lowest value for which the policy rule is activated. The policy rule will be triggered for all values starting from this value up until the high water mark (closed interval). If no low water mark is specified then the policy rule will be activated for all values up to the high water mark. Policy rule with a threshold that does not have any water marks will never be activated.

highWaterMark is upper bound of the threshold. Highest value for which the policy rule is activated. The policy rule will be triggered for all values starting from low water mark up until this value (closed interval). If no high water mark is specified then the policy rule will be activated for all values that are greater than or equal to high water mark.

Both variables are WaterMarkType type, which contains variables count and percentage.

== More configuration examples

=== Simple Example for "Enabled Users Widget"

Now we show very simple example for widget of enabled users, that show only number of enabled users in mP.

As first, we create an object collection with filter for users with value `enabled` in attribute activation/effectiveStatus.

//TODO check after sampleRef is fully in prod
.*Example Object Collection*
[%collapsible]
====
link:https://github.com/Evolveum/midpoint-samples/blob/master/samples/dashboard/howto/collection-enabled-users.xml[Git]

sampleRef::samples/dashboard/howto/collection-enabled-users.xml[]
====

And next we create dashboard with one widget for enabled users.

//TODO check after sampleRef is fully in prod
.*Example Dashboard Configuration*
[%collapsible]
====
link:https://github.com/Evolveum/midpoint-samples/blob/master/samples/dashboard/dashboard-asynchronous-widget.xml[Git]

sampleRef::samples/dashboard/dashboard-asynchronous-widget.xml[]
====

Don't forget to add the new dashboard to admin gui in system configuration.

After accessing the new dashboard in GUI you can see our new widget.

image::enabled-users.png[]

[#_asynchronous_widget]
=== Asynchronous widget

To configure an asynchronous widget we have to use the `displaySourceType` attribute in the widget configuration and set it as `widgetData`.
We set `sourceType` as `objectCollection` because of the redirects to a details page in case of clicking on the widget details.

Also, we need to configure a dashboard report task, which will generate and store data into the widget.
For this we use a dashboard report with the element `storeExportedWidgetData`.

For example, we will use the same case as in the previous example for enabled users.
We create the same object collection.

//TODO check after sampleRef is fully in prod

.*Example Object Collection*
[%collapsible]
====
link:https://github.com/Evolveum/midpoint-samples/blob/master/samples/dashboard/howto/collection-enabled-users.xml[Git]

sampleRef::samples/dashboard/howto/collection-enabled-users.xml[]
====

Next, we have to create a dashboard. We also need to add the attribute `displaySourceType` with value `widgetData`.

//TODO check after sampleRef is fully in prod

.*Example Dashboard Configuration*
[%collapsible]
====
link:https://github.com/Evolveum/midpoint-samples/blob/master/samples/dashboard/dashboard-asynchronous-widget.xml[Git]

sampleRef::samples/dashboard/dashboard-asynchronous-widget.xml[]
====

Finally, we create a report for dashboard.

//TODO check after sampleRef is fully in prod

.*Example Report Configuration*
[%collapsible]
====
link:https://github.com/Evolveum/midpoint-samples/blob/master/samples/dashboard/report-asynchronous-widget.xml[Git]

sampleRef::samples/dashboard/report-asynchronous-widget.xml[]
====

Now we can run the report and midPoint processes the source data for the dashboard.
The resulting data is written to the widget in the dashboard.

include::../raw/file-format.adoc[]

Next time you open the widget in the GUI, midPoint doesn't need to process the source data, it shows the saved data present in the object xml.

image::enabled-users.png[]

== Dashboard views

A dashboard can provide additional info when someone clicks on the *"More info"* button, in this case if we use an "objectCollection" as data "sourceType" we will get tale of objects representing the collection.
The table can be configured and customized. This is done via the "view" container.
Next screenshot is from the example dashboard link:https://github.com/Evolveum/midpoint-samples/tree/master/samples/dashboard[dashboard-system-status].

image::dashboard-screenshot.png[]

== See also

* xref:/midpoint/reference/misc/reports/configuration/dashboard-report/[]
* xref:/midpoint/reference/misc/reports/examples/[]
* xref:/midpoint/reference/admin-gui/collections-views/[]
* xref:/midpoint/features/planned/compliance/[]
* xref:/midpoint/reference/schema/archetypes/[]
* xref:/midpoint/reference/misc/notifications/[]
