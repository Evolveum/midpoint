---
midpoint-feature: [ 'entitlement', 'entitlement-association' ]
doc-type: intro
---
= Entitlements and Associations
:page-wiki-name: Entitlements
:page-wiki-id: 13598822
:page-wiki-metadata-create-user: semancik
:page-wiki-metadata-create-date: 2014-01-09T14:23:08.383+01:00
:page-wiki-metadata-modify-user: vera
:page-wiki-metadata-modify-date: 2020-03-31T14:52:37.580+02:00
:page-toc: top
:page-upkeep-status: yellow

== Introduction

An entitlement is a resource object similar to an account.
But unlike account the entitlement does *not* represent a user.
The entitlement represents a privilege, access right, resource-side role or group or any similar concept.
The entitlements are very frequently used to represent groups.

MidPoint can be configured to fully understand entitlements.
MidPoint can know which resource objects represent groups.
Therefore midPoint can manage group membership in a structured and automated way.
MidPoint can list entitlements and therefore it can be used to create smart and convenient user interfaces.
MidPoint support for entitlements goes beyond the capabilities of vast majority of IDM solutions.

[TIP]
.Why are entitlements so important?
====
Group membership management is traditionally one of the worst nightmares of identity management solutions.
While the concept of grouping is supported by almost every resource the actual group implementation differs a lot.
Some systems store the list of groups in account objects.
Other systems (such as LDAP) store the list of members in group objects.
The systems often store the list of member or group identifiers in a plain string attributes therefore it is difficult to automatically find out which attribute it is.
Support for group membership traditionally involved heavy customization of IDM tools that slowed down the projects.
Even worse it required a very costly maintenance such as manual synchronization of list of groups and roles in the IDM system.
This situation is just not acceptable for efficient IDM deployments.

That's the reason for unified entitlement support in midPoint.
MidPoint can manage all groups in a uniform way regardless of the grouping mechanism that the resource is using.
All that is needed is a handful of configuration lines.
And the nightmare is over.
Especially when entitlements are combined with the power of xref:/midpoint/reference/roles-policies/assignment/[assignments] and xref:/midpoint/reference/synchronization/generic-synchronization/[generic synchronization].
====


== Entitlement Shadow

It is important to remember that entitlement is a *resource object*. Entitlement resides on the resource.
It is *not* an object that is maintained by midPoint.
Entitlements only reflect the reality on the resource.
Similarly to all other resource-side object the entitlement is represented in midPoint only as a xref:/midpoint/reference/resources/shadow/[shadow].

image::schemas-entitlement-1.png[]


== Entitlement, Account and User

The primary purpose of an entitlement is to be associated with accounts (*not* users!).
E.g. an account can be added as a member of a group.
This is realized in midPoint by associating a "group entitlement" with user's account.
MidPoint xref:/midpoint/architecture/archive/subsystems/provisioning/[provisioning component] modifies the resource in appropriate way to add account to a group.
Similarly to other shadow-related operations midPoint then forgets about it.
The information remains only on the resource.
When such association happens the situation looks like this:

image::schemas-entitlement-2.png[]

Similarly to accounts midPoint always reads fresh data from the resource when dealing with entitlements.
Therefore midPoint does not need to remember the association.
It can read it directly from the resource anytime.
And that's exactly what midPoint does when an account xref:/midpoint/reference/resources/shadow/[shadow] is retrieved:

#*TODO* update this figure - associations are represented in slightly different way now#

image::schemas-entitlement-3.png[]

MidPoint fetches the shadow from its repository and it uses the identifiers stored in the shadow to locate account object on the resource.
MidPoint retrieves the account object.
Then midPoint looks for entitlement information in the account and processes any associations.
MidPoint (or the respective connector) may need to retrieve or search additional objects to fully process the associations.
E.g. standard LDAP groups store the list of members in the group object therefore midPoint (or the LDAP connector) needs to search the group objects to fully process the association information.
All that is done transparently.
Regardless what kind of grouping and association mechanism is used, midPoint presents the data in a unified form.

NOTE: Recently-introduced shadow caching feature allows to store parts of these information right in the repository.
This includes relations between shadows, like the group membership.
However, the general principle described above still applies if the requested data are not in the cache.

== Associations

Relations between accounts and entitlements are implemented using _associations_.
(However, associations have much more applications, as described below.)

An association is a relation between a *subject* and one or more *objects*.

When using associations to implement entitlements, subject is the party that receives the entitlement (usually an account), while the object is the entitlement (usually a group).

An association can be either *simple* or *complex*:

* A simple association is just a relation between one subject and one object.
This is the typical way how entitlements are represented.

* A complex association has either multiple objects present, or it can contain additional data (currently attributes and activation data) on its own.
Typical examples:

** *User access rights*: a user has a set of rights to read, write, and/or administer given directories.
Each access right is a value of this association, and has the user (as its subject), the directory (as its object), and the access level (as its attribute).

** *HR contracts*: a person has a set of contracts, where each contract has an organizational unit, a cost center, a job position, validity, and other data.
Each contract is a value of this association.
The person is the subject.
The organization unit, the cost center, and the job position are the objects (assuming they are represented as separate resource objects in HR).
Everything else is stored in association attributes and activation data.

[NOTE]
====
Simple associations are supported by midPoint in full.

Complex associations are xref:/midpoint/versioning/experimental/[an experimental feature]. #TODO is this (still) true?#
====

== Associations and Reference Attributes

Technically, associations are based on so-called *reference attributes*.
These are special attributes describing relations (links) between resource objects.
Each reference attribute resides on the *subject*, and each of its value points to a single *object*.

Normally, reference attributes are hidden from the users.
They are visible only to the lower layers of midPoint, including connectors.

[NOTE]
====
A simple association is equivalent to a reference attribute.

A complex association is implemented using a separate resource object (holding the association data), called *association data object*. #TODO maybe a better name is required#
A subject of the association has a reference to this association data object.
The association data object has references to individual objects of the association.

#TODO a figure would be helpful here#
====

Some connectors, LDAP/AD in particular, support reference attributes out of the box.
Others will provide this support later.
Until that, it is possible to define *simulated references* in midPoint, so that you can utilize the full power of associations in your deployments.

=== Defining Associations

Associations are defined in the xref:/midpoint/reference/resources/resource-configuration/schema-handling/[Resource Schema Handling] section of xref:/midpoint/reference/resources/resource-configuration/[Resource Configuration].

Simulated references are defined in the xref:/midpoint/reference/resources/resource-configuration/capabilities/[Capabilities] section.

Let's cover defining simulated references first.
If you use connector having this capability, feel free to skip to #TODO# section.

=== Simulated References Definition

Each simulated reference has two sides: *object* and *subject*.

==== Participating Resource Objects

First, we have to define what resource objects can participate in the reference on each of these sides.
We call this the *delineation* and we use the following properties to do it:

.Defining participating resource objects
[autowidth]
|===
| Configuration item | Meaning | Example

| `objectClass`
| Name of the object class for the participant.
| `ri:inetOrgPerson`

| `baseContext`
| The definition of base context (resource object container).
This object will be used as a base for searches for the participants.
Usually only the objects that are hierarchically below the `baseContext` are returned by such a search.

Experimental.
a|
[source,xml]
----
<baseContext>
    <objectClass>ri:organizationalUnit</objectClass>
    <filter>
        <q:text>attributes/dn = "ou=groups,dc=evolveum,dc=net"</q:text>
    </filter>
</baseContext>
----

| `searchHierarchyScope`
| Definition of search hierarchy scope.
It specifies how "deep" the search should go into the object hierarchy.
It is only applicable to resources that support hierarchical organization of objects (e.g. LDAP resources).

The value of `sub` means subtree search: it goes deep down the hierarchy, as deep as possible.

The value of `one` means one-level search. The search is reaching just one level below the base context object.

Experimental.
| `sub`

| `auxiliaryObjectClass`
| Restriction of the participant to the specified auxiliary object class, if present.
Typically used if the binding attribute is defined in this class, like `ri:uid` for a `posixAccount`, which is a member of a `posixGroup`.

Currently supported only for the subjects.

Experimental.

| `ri:posixAccount`
|===

There can be zero, one, or more delineations.

#TODO define what is experimental and what is supported here#

The following example shows how to define `groupMembership` reference type that binds together accounts and groups (as subjects) and groups (as objects).

.An example of delineating reference type participants
[source,xml]
----
<capabilities>
    <c:configured xmlns="http://midpoint.evolveum.com/xml/ns/public/resource/capabilities-3">
        <references>
            <type>
                <name>ri:groupMembership</name>
                <subject>
                    <delineation>
                        <objectClass>ri:AccountObjectClass</objectClass>
                    </delineation>
                    <delineation>
                        <objectClass>ri:GroupObjectClass</objectClass>
                    </delineation>
                    <!-- ... -->
                </subject>
                <object>
                    <delineation>
                        <objectClass>ri:GroupObjectClass</objectClass>
                    </delineation>
                    <!-- ... -->
                </object>
                <!-- ... -->
            </type>
            <!-- ... -->
        </references>
    </c:configured>
</capabilities>
----

[NOTE]
====
When defining associations on top of simulated reference attributes, it is possible to re-use the delineation information from the associations themselves.
See #TODO section# below for an example.
====

==== Bindings

Next, we should define how subjects and objects are bound together.

MidPoint supports bindings that either subject-to-object or object-to-subject.

The *subject-to-object* direction is quite simple.
In this case the subject (account) has a list of its entitlements (groups).
It may look like this:

.Subject-to-object direction
[source,ldif]
----
objectclass: account
username: jack
fullName: Jack Sparrow
groups: pirates
groups: captains

objectclass: account
username: will
fullName: Will Turner
groups: pirates

objectclass: group
groupname: pirates

objectclass: group
groupname: captains
----

In this case the binding attribute on the subject side is `groups` and the binding attribute on the object side is `groupname`.

The management of this binding is very easy.

* When reading, midPoint will just retrieve the subject (account) and all of the necessary data are there.
* When updating (i.e., adding or deleting reference values), midPoint will simply add or delete the respective `groups` values on the subject (account).

The *object-to-subject* direction is more complex.
In this case the binding points the other way around.
The object (group) has the list of subjects (accounts) that are the members.
Like this:

.Object-to-subject direction
[source,ldif]
----
objectclass: account
username: jack
fullName: Jack Sparrow

objectclass: account
username: will
fullName: Will Turner

objectclass: group
groupname: pirates
members: jack
members: will

objectclass: group
groupname: captains
members: jack
----

In this case the binding attribute on the subject side is `username` and the binding attribute on the object side is `members`.

The management of this binding is also complex.

* When reading, we cannot simply retrieve the subject (account).
The membership data are not there.
What we need is to _search_ for all the objects.
E.g. if we want to get a list of all groups that `jack` belongs to then we need to search for all groups that match the filter `(members=jack)`.

* When updating (i.e., adding or deleting reference values), midPoint will have to update `members` attribute of concrete groups: the `jack` value is either added to, or deleted from, that attribute on each group whose membership is being added or deleted from `jack`.

The direction of the association has significant consequences in many areas.
Firstly there is performance impact.
The object-to-subject associations need more operations than the subject-to-object associations.
And these additional operations are usually big searches over the resource.
Secondly this has consequences for troubleshooting.
Different types of associations produce different connector operations.
Especially the searches for object-to-subject associations may be quite tricky to troubleshoot.

==== Primary and Secondary Bindings

There are two kinds of bindings:

* *Primary binding*: This is the one used to update the reference.
It can be also used to retrieve the reference values, if no other binding is defined.
It may be either object-to-subject or subject-to-object.

* *Secondary binding*: There are situations where the resource provides additional data that allow more efficient retrieval of reference values.
In such cases, you can define secondary binding that utilizes them.
It is always subject-to-object, and is defined only if the primary binding is object-to-subject.

An real-life example for an LDAP resource:

* The primary binding may be between account `ri:dn` attribute and group `ri:members` one.
It is used for updating the user's group membership data.
* The secondary binding may be between account `ri:memberOf` attribute and group `ri:dn` one.
It is used for reading the user's group membership data.
The `memberOf` (or similar) attribute is typically provided by advanced LDAP servers.
It is a virtual read-only account attribute that contains a list of groups the account is a member of.

==== Some Examples

This is the `groupMembership` reference type typical for LDAP servers.
(If, for some reason, you don't use the native capability of the LDAP connector for this.)

* When querying, `ri:memberOf` attribute on the subject (account or group) is used.
* When updating, `ri:members` attribute on the object (group) is used.
* The reference is visible as (virtual) `group` reference attribute on the subject (account or group).
#TODO explain this#

.An example of LDAP group membership definition
[source,xml]
----
<capabilities>
    <c:configured xmlns="http://midpoint.evolveum.com/xml/ns/public/resource/capabilities-3">
        <references>
            <type>
                <name>ri:groupMembership</name>
                <subject>
                    <delineation>
                        <objectClass>ri:inetOrgPerson</objectClass>
                    </delineation>
                    <delineation>
                        <objectClass>ri:groupOfNames</objectClass>
                    </delineation>
                    <primaryBindingAttributeRef>ri:dn</primaryBindingAttributeRef>
                    <secondaryBindingAttributeRef>ri:memberOf</secondaryBindingAttributeRef>
                    <localItemName>ri:group</localItemName>
                </subject>
                <object>
                    <delineation>
                        <objectClass>ri:groupOfNames</objectClass>
                    </delineation>
                    <primaryBindingAttributeRef>ri:members</primaryBindingAttributeRef>
                    <secondaryBindingAttributeRef>ri:dn</secondaryBindingAttributeRef>
                </object>
                <direction>objectToSubject</direction>
            </type>
        </references>
    </c:configured>
</capabilities>
----

This is a typical example of subject-to-object reference.

* When querying and updating, `ri:privileges` attribute on the subject (account) is used.
* The reference is visible as (virtual) `ri:priv` reference attribute on the subject (account).

.An example of a custom "privileges" definition
[source,xml]
----
<capabilities>
    <c:configured xmlns="http://midpoint.evolveum.com/xml/ns/public/resource/capabilities-3">
        <references>
            <type>
                <name>ri:accountPrivilege</name>
                <subject>
                    <delineation>
                        <objectClass>ri:account</objectClass>
                    </delineation>
                    <primaryBindingAttributeRef>ri:privileges</primaryBindingAttributeRef>
                    <localItemName>ri:priv</localItemName>
                </subject>
                <object>
                    <delineation>
                        <objectClass>ri:privilege</objectClass>
                    </delineation>
                    <primaryBindingAttributeRef>icfs:name</primaryBindingAttributeRef>
                </object>
                <direction>subjectToObject</direction>
            </type>
        </references>
    </c:configured>
</capabilities>
----

=== Association Participants Definition

Now, let's have a look at how associations - or more precisely, association _types_ - are defined on top of reference attributes.

First of all, association types are defined independently of participating object types.
Each type of associations is contained in its own `associationType` item under `schemaHandling`.

A minimalistic definition of an association type looks like this:

.A minimalistic association type definition
[source,xml]
----
<resource>
    <!-- ... -->
    <schemaHandling>
        <!-- ... -->
        <associationType>
            <name>groupMembership</name>
            <subject>
                <objectType>
                    <kind>account</kind>
                    <intent>default</intent>
                </objectType>
                <association>
                    <ref>ri:group</ref>
                </association>
            </subject>
        </associationType>
    </schemaHandling>
</resource>
----

The definition must contain the association type name, which must be unique resource-wide.

Then, it must contain a specification of the subject type or types to which it applies.
In the above example, the `groupMembership` association type applies to `account/default` object type.
The `association` item then defines how the association manifests itself on that object type.
In particular, `ri:group` is the name under which the association is present on that shadows.

If not specified otherwise, `ri:group` is the reference attribute that provides the data for this association.
In other words, everything, that the connector (or the module for simulating reference attributes) provides within that attribute, is considered as values of this association.

The engineer can restrict the values from the connector by looking at specific object types.

#TODO continue from here#

.An example of association type definition
[source,xml]
----
<resource>
    <!-- ... -->
    <schemaHandling>
        <!-- ... -->
        <associationType>
            <name>securityGroupMembership</name>
            <subject>
                <objectType>
                    <kind>account</kind>
                    <intent>default</intent>
                </objectType>
                <association>
                    <ref>ri:group</ref>
                    <!-- ... -->
                </association>
            </subject>
            <object>
                <objectType>
                    <kind>entitlement</kind>
                    <intent>security-group</kind>
                </objectType>
            </object>
        </associationType>
    </schemaHandling>
</resource>
----


=== Association Behavior Definition

#MidPoint works with associations in almost the same way how it works with resource object attributes.
The associations are not stored in midPoint (xref:/midpoint/reference/resources/shadow/[Shadow Objects]). The associations are retrieved fresh from the resource.
This applies to all parts of midPoint and particularly to xref:/midpoint/reference/synchronization/introduction/[synchronization] and the user interface.
E.g. the user interface will retrieve the associations only when the resource object (account) on the projection tab is expanded.
Exactly at the same time when attributes are retrieved.#


=== Associations Versus Attributes

#Some midPoint deployments may have a dilemma whether to use associations or simple attributes.
E.g. the `groups` attribute in the example above may as well be managed as a simple multi-valued attribute.
No need for associations here.
However there are two arguments in favor of associations:#

* #Associations are smart.
Association knows that the values in that attribute are supposed to represent group name.
The midPoint user interface may use this information to list all available groups when user wants to add a new associations.
User then simply selects value from the list.
No need to enter the group name manually.#

* #The object-to-subject associations are very difficult to model as simple attributes.
In this case the attribute that needs to be modified is in fact in a different object.
MidPoint tries to isolate the operations to a single object (or a set of related objects).
Therefore modeling object-to-subject associations using simple attributes may be very difficult.
The association mechanisms makes this very easy.#


== Assigning Entitlements

Entitlements can be easily assigned to accounts by using the xref:/midpoint/reference/roles-policies/assignment/[assignment] mechanism.
This allows the construction of roles that automatically associate user's accounts with appropriate groups.
See xref:/midpoint/reference/roles-policies/assignment/configuration/[Assignment Configuration] page for more details.


== Entitlement Membership Removal

Most midPoint operations are delta-based.
E.g. if user interface is used to add or remove an assignment a xref:/midpoint/devel/prism/concepts/deltas/[delta] is created and sent as a parameter of the operation.
In this case we know what has changed.
Therefore we can easily add remove entitlement membership.
We can do this even if the entitlement is set to be _tolerant_. We can do this because we know that the last assignment that "induced" that group was just removed.

But the situation is different for reconciliation and recompute.
E.g in case that the role definition is changed.
There are in fact two operation: change of the role and then reconcile the user.
These operations are independent.
Therefore for the second operation there is no delta.
MidPoint does not know what has changed in the role.
Therefore it cannot use the same logic to remove the user from the entilement.
Slightly different logic is used in reconciliation.
Logic that is not based on deltas (because there are none).
And in this case the tolerant flag is important.
If it is set to true then midPoint will NOT remove the extra values from the attribute or the extra entitlements.
If it is set to false then midPoint will remove them.

For these operations to work correctly even in reconciliation it is important to set the _tolerant_ property.
Please make sure you have the association set to non-tolerant in the schemaHandling section of the resource definition.
Like this:

[source,xml]
----
<resource>
    <schemaHandling>
        ...
        <association>
            <ref>ri:group</ref>
            <tolerant>false</tolerant>
            ...
        </association>
        ...
----

This has to be defined in the schemaHandling and *not* in the role or meta-role.
The tolerance is the property of the attribute/association itself and *not* a property of any mapping, role or value.
The values that are not given by any role and just that - not given by any role.
So we do not have any role definition that we can apply to them.
Therefore the setting whether the attribute/association is tolerant or not is somehow "global".
Therefore it needs to be defined in `schemaHandling`.

Also, please make sure that your mappings are strong, e.g.

[source,xml]
----
<role>
     ...
     <inducement>
         <construction>
             ...
             <association>
                 <ref>ri:group</ref>
                 <outbound>
                     <strength>strong</strength>
                     ...
                 </outbound>
             </association>
         </construction>
     </inducement>
----

Mappings that are of "normal" strength are inherently delta-based and they are usually NOT processed by the reconciliation at all.
For "normal" mappings the last change wins.
But in reconciliation we have no idea what change was the last one - whether the one on the resource or the one in midPoint.
Therefore we prefer the conservative approach and we rather maintain status quo.


== See Also

* xref:/midpoint/reference/resources/shadow/[Shadow Objects]

* xref:/midpoint/reference/synchronization/generic-synchronization/[Generic Synchronization]

* xref:/midpoint/reference/roles-policies/assignment/[Assignment]

* xref:/midpoint/reference/resources/resource-configuration/schema-handling/[Resource Schema Handling]
