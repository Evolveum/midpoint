/*
 * Copyright (C) 2010-2025 Evolveum and contributors
 *
 * This work is dual-licensed under the Apache License 2.0
 * and European Union Public License. See LICENSE file for details.
 */

package com.evolveum.midpoint.schema.util;

import com.evolveum.midpoint.prism.*;

import com.evolveum.midpoint.prism.path.ItemPath;
import com.evolveum.midpoint.xml.ns._public.common.common_3.*;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Iterator;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Utility class for AI-related features.
 *
 * Values generated by AI are marked with metadata as described in {@link #createAiProvenanceMetadata()}.
 */
public class AiUtil {

    /**
     * Currently, we use the origin of {@link SystemObjectsType#ORIGIN_ARTIFICIAL_INTELLIGENCE} (with all other items null)
     * to indicate that the value was provided by AI.
     */
    private static final ProvenanceMetadataType AI_PROVENANCE_METADATA = createAiProvenanceMetadata();

    /** Convenience variant of {@link #markAsAiProvided(PrismValue)}. Marks the leaf nodes in the whole value. */
    public static <C extends Containerable> C markAsAiProvided(@NotNull C value) {
        markAsAiProvided(value.asPrismContainerValue());
        return value;
    }

    /** Convenience variant of {@link #markAsAiProvided(PrismValue)}. Marks the leaf nodes in items in the value (if present). */
    public static <C extends Containerable> C markAsAiProvided(@NotNull C containerable, ItemPath... paths) {
        for (ItemPath path : paths) {
            Item<?, ?> item = containerable.asPrismContainerValue().findItem(path);
            if (item != null) {
                for (var value : item.getValues()) {
                    markAsAiProvided(value);
                }
            }
        }
        return containerable;
    }

    /**
     * Marks all leaf values (i.e. property and reference values) as provided by AI. Uses value metadata to indicate that.
     * Does nothing if the value is {@code null}.
     *
     * The values themselves must be mutable!
     *
     * TODO The question is whether we should also mark the container values as AI-provided.
     */
    public static void markAsAiProvided(@Nullable PrismValue value) {
        if (value != null) {
            value.acceptVisitor(
                    visitable -> {
                        if (visitable instanceof ValueMetadata) {
                            return false; // we do not want to mark metadata itself
                        } else if (visitable instanceof PrismValue prismValue) {
                            if (visitable instanceof PrismContainerValue<?>) {
                                return true; // we want to drill down, but we do not want to mark the container value itself
                            } else {
                                ValueMetadataTypeUtil.getOrCreateMetadata(prismValue, AI_PROVENANCE_METADATA);
                                return false; // PPVs and PRVs have no children to visit
                            }
                        } else if (visitable instanceof Item) {
                            return true; // we want to visit the values
                        } else {
                            throw new IllegalArgumentException("Unexpected visitable type: " + visitable.getClass());
                        }
                    }
            );
        }
    }

    //TODO tmp method for using in connector generation wizard, remove after MVP
    public static void markContainerValueAsAiProvided(@Nullable PrismContainerValue<?> value) {
        if (value != null) {
            ValueMetadataTypeUtil.getOrCreateMetadata(value, AI_PROVENANCE_METADATA);
        }
    }

    // TODO methods for clearing the AI mark

    /**
     * Returns {@code true} if the value is not {@code null} and is marked (at the root level) as provided by AI.
     */
    public static boolean isMarkedAsAiProvided(@Nullable PrismValue value) {
        return value != null
                && value.hasValueMetadata()
                && ValueMetadataTypeUtil.getMetadata(value, AI_PROVENANCE_METADATA) != null;
    }

    private static ProvenanceMetadataType createAiProvenanceMetadata() {
        var metadata = new ProvenanceMetadataType()
                .acquisition(new ProvenanceAcquisitionType()
                        .originRef(SystemObjectsType.ORIGIN_ARTIFICIAL_INTELLIGENCE.value(), ServiceType.COMPLEX_TYPE));
        metadata.freeze();
        return metadata;
    }

    /**
     * Synchronizes AI provenance metadata between the old and new value.
     * <ul>
     *     <li>If the old value was marked as AI-provided and the new value differs,
     *         the AI provenance is removed from the new value.</li>
     *     <li>If the old and new values are equal, the AI provenance mark is re-applied
     *         to the new value.</li>
     * </ul>
     */
    public static void syncAiProvenanceWithChangeIfApplied(@NotNull PrismValue newValue, @NotNull PrismValue oldValue) {
        if (AiUtil.isMarkedAsAiProvided(oldValue)) {
            if (!Objects.equals(oldValue.getRealValue(), newValue.getRealValue())) {
                AiUtil.unmarkAsAiProvided(newValue);
            } else {
                AiUtil.markAsAiProvided(newValue);
            }
        }
    }

    /**
     * Recursively removes AI provenance metadata from the given PrismValue and its children.
     * <p>
     * Traverses property and reference values, but skips metadata containers themselves.
     * </p>
     */
    public static void unmarkAsAiProvided(@Nullable PrismValue value) {
        if (value == null) {
            return;
        }
        value.acceptVisitor(visitable -> {
            if (visitable instanceof ValueMetadata) {
                return false;
            } else if (visitable instanceof PrismValue prismValue) {
                if (prismValue instanceof PrismContainerValue<?>) {
                    return true;
                } else {
                    removeAiProvenanceMetadata(prismValue);
                    return false;
                }
            } else {
                return visitable instanceof Item;
            }
        });
    }

    /**
     * Removes AI provenance metadata entries from the given PrismValue.
     * <p>
     * Operates directly on the {@link ValueMetadata} container of the value.
     * Returns {@code true} if at least one AI provenance entry was removed.
     * </p>
     */
    private static boolean removeAiProvenanceMetadata(@NotNull PrismValue prismValue) {

        ValueMetadata vmc = prismValue.getValueMetadata();
        if (vmc.hasNoValues()) {
            return false;
        }

        Iterator<PrismContainerValue<Containerable>> it = vmc.getValues().iterator();
        boolean removed = false;

        while (it.hasNext()) {
            PrismContainerValue<?> pcv = it.next();
            ValueMetadataType vmType = pcv.getRealValue();
            if (vmType == null || vmType.getProvenance() == null) {
                continue;
            }
            if (containsMatchingOriginRefMetadata(vmType.getProvenance(), AiUtil.AI_PROVENANCE_METADATA)) {
                it.remove();
                removed = true;
            }
        }

        if (removed && vmc.hasNoValues()) {
            vmc.clear();
        }
        return removed;
    }

    /**
     * Compares two provenance metadata beans by their acquisition origins.
     * <p>
     * Returns {@code true} if both contain the same set of {@code originRef} OIDs,
     * regardless of order. Other provenance fields are ignored.
     * </p>
     */
    //TODO
    public static boolean containsMatchingOriginRefMetadata(
            @NotNull ProvenanceMetadataType candidateProvenance,
            @NotNull ProvenanceMetadataType expectedProvenance) {

        Set<String> candidateOids = candidateProvenance.getAcquisition().stream()
                .map(a -> a.getOriginRef() != null ? a.getOriginRef().getOid() : null)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        Set<String> expectedOids = expectedProvenance.getAcquisition().stream()
                .map(a -> a.getOriginRef() != null ? a.getOriginRef().getOid() : null)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        return candidateOids.equals(expectedOids);
    }
}
