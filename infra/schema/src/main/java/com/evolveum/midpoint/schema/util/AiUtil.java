/*
 * Copyright (C) 2010-2025 Evolveum and contributors
 *
 * This work is dual-licensed under the Apache License 2.0
 * and European Union Public License. See LICENSE file for details.
 */

package com.evolveum.midpoint.schema.util;

import com.evolveum.midpoint.prism.*;

import com.evolveum.midpoint.prism.path.ItemPath;
import com.evolveum.midpoint.xml.ns._public.common.common_3.*;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Iterator;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * Utility class for AI-related features.
 *
 * Values generated by AI are marked with metadata as described in {@link #createAiProvenanceMetadata()}.
 */
public class AiUtil {

    /**
     * Currently, we use the origin of {@link SystemObjectsType#ORIGIN_ARTIFICIAL_INTELLIGENCE} (with all other items null)
     * to indicate that the value was provided by AI.
     */
    private static final ProvenanceMetadataType AI_PROVENANCE_METADATA = createAiProvenanceMetadata();

    /** Convenience variant of {@link #markAsAiProvided(PrismValue)}. Marks the leaf nodes in the whole value. */
    public static <C extends Containerable> C markAsAiProvided(@NotNull C value) {
        markAsAiProvided(value.asPrismContainerValue());
        return value;
    }

    /** Convenience variant of {@link #markAsAiProvided(PrismValue)}. Marks the leaf nodes in items in the value (if present). */
    public static <C extends Containerable> C markAsAiProvided(@NotNull C containerable, ItemPath... paths) {
        for (ItemPath path : paths) {
            Item<?, ?> item = containerable.asPrismContainerValue().findItem(path);
            if (item != null) {
                for (var value : item.getValues()) {
                    markAsAiProvided(value);
                }
            }
        }
        return containerable;
    }

    /**
     * Marks all leaf values (i.e. property and reference values) as provided by AI. Uses value metadata to indicate that.
     * Does nothing if the value is {@code null}.
     *
     * The values themselves must be mutable!
     *
     * TODO The question is whether we should also mark the container values as AI-provided.
     */
    public static void markAsAiProvided(@Nullable PrismValue value) {
        forEachLeafValue(value, pv -> ValueMetadataTypeUtil.getOrCreateMetadata(pv, AI_PROVENANCE_METADATA));
    }

    //TODO tmp method for using in connector generation wizard, remove after MVP
    public static void markContainerValueAsAiProvided(@Nullable PrismContainerValue<?> value) {
        if (value != null) {
            ValueMetadataTypeUtil.getOrCreateMetadata(value, AI_PROVENANCE_METADATA);
        }
    }

    /**
     * Returns {@code true} if the value is not {@code null} and is marked (at the root level) as provided by AI.
     */
    public static boolean isMarkedAsAiProvided(@Nullable PrismValue value) {
        return value != null
                && value.hasValueMetadata()
                && (ValueMetadataTypeUtil.getMetadata(value, AI_PROVENANCE_METADATA) != null || hasAiProvenance(value));
    }

    /**
     * Checks whether the given value contains AI provenance metadata (by matching originRef OIDs).
     * Needed for cases like {@code newValue}, where cloned metadata differs from the static AI_PROVENANCE_METADATA instance.
     */
    private static boolean hasAiProvenance(@NotNull PrismValue value) {
        return anyMetadataEntry(value, vmType -> vmType.getProvenance() != null
                && containsMatchingOriginRefMetadata(vmType.getProvenance(), AI_PROVENANCE_METADATA));
    }

    private static ProvenanceMetadataType createAiProvenanceMetadata() {
        var metadata = new ProvenanceMetadataType()
                .acquisition(new ProvenanceAcquisitionType()
                        .originRef(SystemObjectsType.ORIGIN_ARTIFICIAL_INTELLIGENCE.value(), ServiceType.COMPLEX_TYPE));
        metadata.freeze();
        return metadata;
    }

    /**
     * Synchronizes AI provenance metadata between the old and new value.
     * <ul>
     *     <li>If the old value was marked as AI-provided and the new value differs,
     *         the AI provenance is removed from the new value.</li>
     *     <li>If the old and new values are equal, the AI provenance mark is re-applied
     *         to the new value.</li>
     * </ul>
     */
    public static void syncAiProvenanceWithChangeIfApplied(@NotNull PrismValue newValue, @NotNull PrismValue oldValue) {
        if (AiUtil.isMarkedAsAiProvided(oldValue)) {
            if (!Objects.equals(oldValue.getRealValue(), newValue.getRealValue())) {
                AiUtil.unmarkAsAiProvided(newValue);
            } else {
                AiUtil.markAsAiProvided(newValue);
            }
        }
    }

    /**
     * Recursively removes AI provenance metadata from the given PrismValue and its children.
     * <p>
     * Traverses property and reference values, but skips metadata containers themselves.
     * </p>
     */
    public static void unmarkAsAiProvided(@Nullable PrismValue value) {
        forEachLeafValue(value, AiUtil::removeAiProvenanceMetadata);
    }

    /**
     * Removes AI provenance metadata entries from the given PrismValue.
     * <p>
     * Operates directly on the {@link ValueMetadata} container of the value.
     * Returns {@code true} if at least one AI provenance entry was removed.
     * </p>
     */
    private static boolean removeAiProvenanceMetadata(@NotNull PrismValue prismValue) {

        ValueMetadata vmc = prismValue.getValueMetadata();
        if (vmc.hasNoValues()) {
            return false;
        }

        Iterator<PrismContainerValue<Containerable>> it = vmc.getValues().iterator();
        boolean removed = false;

        while (it.hasNext()) {
            PrismContainerValue<?> pcv = it.next();
            ValueMetadataType vmType = pcv.getRealValue();
            if (vmType == null || vmType.getProvenance() == null) {
                continue;
            }
            if (containsMatchingOriginRefMetadata(vmType.getProvenance(), AiUtil.AI_PROVENANCE_METADATA)) {
                it.remove();
                removed = true;
            }
        }

        if (removed && vmc.hasNoValues()) {
            vmc.clear();
        }
        return removed;
    }

    /**
     * Compares two provenance metadata beans by their acquisition origins.
     * <p>
     * Returns {@code true} if both contain the same set of {@code originRef} OIDs,
     * regardless of order. Other provenance fields are ignored.
     * </p>
     */
    //TODO
    public static boolean containsMatchingOriginRefMetadata(
            @NotNull ProvenanceMetadataType candidateProvenance,
            @NotNull ProvenanceMetadataType expectedProvenance) {

        Set<String> candidateOids = candidateProvenance.getAcquisition().stream()
                .map(a -> a.getOriginRef() != null ? a.getOriginRef().getOid() : null)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        Set<String> expectedOids = expectedProvenance.getAcquisition().stream()
                .map(a -> a.getOriginRef() != null ? a.getOriginRef().getOid() : null)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        return candidateOids.equals(expectedOids);
    }

    /** Convenience variant to mark specific items within the containerable as invalid. */
    public static <C extends Containerable> C markAsInvalid(@NotNull C containerable, @Nullable String validationError, ItemPath... paths) {
        for (ItemPath path : paths) {
            Item<?, ?> item = containerable.asPrismContainerValue().findItem(path);
            if (item != null) {
                for (var v : item.getValues()) {
                    markAsInvalid(v, validationError);
                }
            }
        }
        return containerable;
    }

    /** Marks leaf values as invalid with an optional validationError. */
    public static void markAsInvalid(@Nullable PrismValue value, @Nullable String validationError) {
        forEachLeafValue(value, pv -> setValidationOnValue(pv, validationError));
    }

    /** Returns {@code true} if the value has validation metadata at the root level. */
    public static boolean isMarkedAsInvalid(@Nullable PrismValue value) {
        return value != null && value.hasValueMetadata() && hasValidation(value);
    }

    private static boolean hasValidation(@NotNull PrismValue value) {
        return anyMetadataEntry(value, vmType -> vmType.getValidation() != null);
    }

    private static void setValidationOnValue(@NotNull PrismValue prismValue, @Nullable String validationError) {
        ValueMetadata vmc = prismValue.getValueMetadata();
        ValueMetadataType target = ValueMetadataTypeUtil.getOrCreateMetadataWithValidation(vmc);
        if (validationError != null) {
            ValueMetadataTypeUtil.getOrCreateValidationMetadata(target).setValidationError(validationError);
        } else {
            ValueMetadataTypeUtil.getOrCreateValidationMetadata(target);
        }
    }

    /** Shared visitor to act on leaf values (property/reference). Skips metadata and recurses into containers. */
    private static void forEachLeafValue(@Nullable PrismValue value, @NotNull Consumer<PrismValue> onLeaf) {
        if (value == null) {
            return;
        }
        value.acceptVisitor(visitable -> {
            if (visitable instanceof ValueMetadata) {
                return false;
            } else if (visitable instanceof PrismValue prismValue) {
                if (prismValue instanceof PrismContainerValue<?>) {
                    return true;
                } else {
                    onLeaf.accept(prismValue);
                    return false;
                }
            } else {
                return visitable instanceof Item;
            }
        });
    }

    /** Checks if any metadata entry on the root value satisfies the provided predicate. */
    private static boolean anyMetadataEntry(@NotNull PrismValue value, @NotNull Predicate<ValueMetadataType> predicate) {
        if (!value.hasValueMetadata()) {
            return false;
        }
        ValueMetadata vmc = value.getValueMetadata();
        if (vmc.hasNoValues()) {
            return false;
        }
        for (PrismContainerValue<Containerable> pcv : vmc.getValues()) {
            ValueMetadataType vmType = pcv.getRealValue();
            if (vmType != null && predicate.test(vmType)) {
                return true;
            }
        }
        return false;
    }

}
