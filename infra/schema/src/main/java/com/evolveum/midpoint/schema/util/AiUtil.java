/*
 * Copyright (C) 2010-2025 Evolveum and contributors
 *
 * This work is dual-licensed under the Apache License 2.0
 * and European Union Public License. See LICENSE file for details.
 */

package com.evolveum.midpoint.schema.util;

import com.evolveum.midpoint.prism.*;

import com.evolveum.midpoint.prism.path.ItemPath;
import com.evolveum.midpoint.xml.ns._public.common.common_3.*;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Iterator;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Utility class for AI-related features.
 *
 * Values generated by AI are marked with metadata as described in {@link #createAiProvenanceMetadata()}.
 */
public class AiUtil {

    /**
     * Currently, we use the origin of {@link SystemObjectsType#ORIGIN_ARTIFICIAL_INTELLIGENCE} (with all other items null)
     * to indicate that the value was provided by AI.
     */
    private static final ProvenanceMetadataType AI_PROVENANCE_METADATA = createAiProvenanceMetadata();

    /** Convenience variant of {@link #markAsAiProvided(PrismValue)}. Marks the leaf nodes in the whole value. */
    public static <C extends Containerable> C markAsAiProvided(@NotNull C value) {
        markAsAiProvided(value.asPrismContainerValue());
        return value;
    }

    /** Convenience variant of {@link #markAsAiProvided(PrismValue)}. Marks the leaf nodes in items in the value (if present). */
    public static <C extends Containerable> C markAsAiProvided(@NotNull C containerable, ItemPath... paths) {
        for (ItemPath path : paths) {
            Item<?, ?> item = containerable.asPrismContainerValue().findItem(path);
            if (item != null) {
                for (var value : item.getValues()) {
                    markAsAiProvided(value);
                }
            }
        }
        return containerable;
    }

    /**
     * Marks all leaf values (i.e. property and reference values) as provided by AI. Uses value metadata to indicate that.
     * Does nothing if the value is {@code null}.
     *
     * The values themselves must be mutable!
     *
     * TODO The question is whether we should also mark the container values as AI-provided.
     */
    public static void markAsAiProvided(@Nullable PrismValue value) {
        if (value != null) {
            value.acceptVisitor(
                    visitable -> {
                        if (visitable instanceof ValueMetadata) {
                            return false; // we do not want to mark metadata itself
                        } else if (visitable instanceof PrismValue prismValue) {
                            if (visitable instanceof PrismContainerValue<?>) {
                                return true; // we want to drill down, but we do not want to mark the container value itself
                            } else {
                                ValueMetadataTypeUtil.getOrCreateMetadata(prismValue, AI_PROVENANCE_METADATA);
                                return false; // PPVs and PRVs have no children to visit
                            }
                        } else if (visitable instanceof Item) {
                            return true; // we want to visit the values
                        } else {
                            throw new IllegalArgumentException("Unexpected visitable type: " + visitable.getClass());
                        }
                    }
            );
        }
    }

    //TODO tmp method for using in connector generation wizard, remove after MVP
    public static void markContainerValueAsAiProvided(@Nullable PrismContainerValue<?> value) {
        if (value != null) {
            ValueMetadataTypeUtil.getOrCreateMetadata(value, AI_PROVENANCE_METADATA);
        }
    }

    /**
     * Returns {@code true} if the value is not {@code null} and is marked (at the root level) as provided by AI.
     */
    public static boolean isMarkedAsAiProvided(@Nullable PrismValue value) {
        return value != null
                && value.hasValueMetadata()
                && (ValueMetadataTypeUtil.getMetadata(value, AI_PROVENANCE_METADATA) != null || hasAiProvenance(value));
    }

    /**
     * Checks whether the given value contains AI provenance metadata (by matching originRef OIDs).
     * Needed for cases like {@code newValue}, where cloned metadata differs from the static AI_PROVENANCE_METADATA instance.
     */
    private static boolean hasAiProvenance(@NotNull PrismValue value) {
        if (!value.hasValueMetadata()) {
            return false;
        }
        ValueMetadata vmc = value.getValueMetadata();
        if (vmc.hasNoValues()) {
            return false;
        }
        for (PrismContainerValue<Containerable> pcv : vmc.getValues()) {
            ValueMetadataType vmType = pcv.getRealValue();
            if (vmType != null && vmType.getProvenance() != null
                    && containsMatchingOriginRefMetadata(vmType.getProvenance(), AI_PROVENANCE_METADATA)) {
                return true;
            }
        }
        return false;
    }

    private static ProvenanceMetadataType createAiProvenanceMetadata() {
        var metadata = new ProvenanceMetadataType()
                .acquisition(new ProvenanceAcquisitionType()
                        .originRef(SystemObjectsType.ORIGIN_ARTIFICIAL_INTELLIGENCE.value(), ServiceType.COMPLEX_TYPE));
        metadata.freeze();
        return metadata;
    }

    /**
     * Synchronizes AI provenance metadata between the old and new value.
     * <ul>
     *     <li>If the old value was marked as AI-provided and the new value differs,
     *         the AI provenance is removed from the new value.</li>
     *     <li>If the old and new values are equal, the AI provenance mark is re-applied
     *         to the new value.</li>
     * </ul>
     */
    public static void syncAiProvenanceWithChangeIfApplied(@NotNull PrismValue newValue, @NotNull PrismValue oldValue) {
        if (AiUtil.isMarkedAsAiProvided(oldValue)) {
            if (!Objects.equals(oldValue.getRealValue(), newValue.getRealValue())) {
                AiUtil.unmarkAsAiProvided(newValue);
            } else {
                AiUtil.markAsAiProvided(newValue);
            }
        }
    }

    /**
     * Recursively removes AI provenance metadata from the given PrismValue and its children.
     * <p>
     * Traverses property and reference values, but skips metadata containers themselves.
     * </p>
     */
    public static void unmarkAsAiProvided(@Nullable PrismValue value) {
        if (value == null) {
            return;
        }
        value.acceptVisitor(visitable -> {
            if (visitable instanceof ValueMetadata) {
                return false;
            } else if (visitable instanceof PrismValue prismValue) {
                if (prismValue instanceof PrismContainerValue<?>) {
                    return true;
                } else {
                    removeAiProvenanceMetadata(prismValue);
                    return false;
                }
            } else {
                return visitable instanceof Item;
            }
        });
    }

    /**
     * Removes AI provenance metadata entries from the given PrismValue.
     * <p>
     * Operates directly on the {@link ValueMetadata} container of the value.
     * Returns {@code true} if at least one AI provenance entry was removed.
     * </p>
     */
    private static boolean removeAiProvenanceMetadata(@NotNull PrismValue prismValue) {

        ValueMetadata vmc = prismValue.getValueMetadata();
        if (vmc.hasNoValues()) {
            return false;
        }

        Iterator<PrismContainerValue<Containerable>> it = vmc.getValues().iterator();
        boolean removed = false;

        while (it.hasNext()) {
            PrismContainerValue<?> pcv = it.next();
            ValueMetadataType vmType = pcv.getRealValue();
            if (vmType == null || vmType.getProvenance() == null) {
                continue;
            }
            if (containsMatchingOriginRefMetadata(vmType.getProvenance(), AiUtil.AI_PROVENANCE_METADATA)) {
                it.remove();
                removed = true;
            }
        }

        if (removed && vmc.hasNoValues()) {
            vmc.clear();
        }
        return removed;
    }

    /**
     * Compares two provenance metadata beans by their acquisition origins.
     * <p>
     * Returns {@code true} if both contain the same set of {@code originRef} OIDs,
     * regardless of order. Other provenance fields are ignored.
     * </p>
     */
    //TODO
    public static boolean containsMatchingOriginRefMetadata(
            @NotNull ProvenanceMetadataType candidateProvenance,
            @NotNull ProvenanceMetadataType expectedProvenance) {

        Set<String> candidateOids = candidateProvenance.getAcquisition().stream()
                .map(a -> a.getOriginRef() != null ? a.getOriginRef().getOid() : null)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        Set<String> expectedOids = expectedProvenance.getAcquisition().stream()
                .map(a -> a.getOriginRef() != null ? a.getOriginRef().getOid() : null)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        return candidateOids.equals(expectedOids);
    }

    /**
     * Marks all leaf values (property and reference values) as invalid by attaching validation metadata.
     * Optional reason can be provided. Does nothing if the value is {@code null}.
     */
    public static <C extends Containerable> C markAsInvalid(@NotNull C value, @Nullable String reason) {
        markAsInvalid(value.asPrismContainerValue(), reason);
        return value;
    }

    /** Convenience variant to mark specific items within the containerable as invalid. */
    public static <C extends Containerable> C markAsInvalid(@NotNull C containerable, @Nullable String reason, ItemPath... paths) {
        for (ItemPath path : paths) {
            Item<?, ?> item = containerable.asPrismContainerValue().findItem(path);
            if (item != null) {
                for (var v : item.getValues()) {
                    markAsInvalid(v, reason);
                }
            }
        }
        return containerable;
    }

    /** Marks leaf values as invalid with an optional reason. */
    public static void markAsInvalid(@Nullable PrismValue value, @Nullable String reason) {
        if (value != null) {
            value.acceptVisitor(visitable -> {
                if (visitable instanceof ValueMetadata) {
                    return false; // do not mark metadata itself
                } else if (visitable instanceof PrismValue prismValue) {
                    if (prismValue instanceof PrismContainerValue<?>) {
                        return true; // drill down, but do not mark the container value itself
                    } else {
                        setValidationOnValue(prismValue, reason);
                        return false; // PPVs and PRVs have no children to visit
                    }
                } else if (visitable instanceof Item) {
                    return true; // visit the values
                } else {
                    throw new IllegalArgumentException("Unexpected visitable type: " + visitable.getClass());
                }
            });
        }
    }

    /** Returns {@code true} if the value has validation metadata at the root level. */
    public static boolean isMarkedAsInvalid(@Nullable PrismValue value) {
        return value != null && value.hasValueMetadata() && hasValidation(value);
    }

    /** Removes validation metadata recursively from the given value and its children. */
    public static void unmarkAsInvalid(@Nullable PrismValue value) {
        if (value == null) {
            return;
        }
        value.acceptVisitor(visitable -> {
            if (visitable instanceof ValueMetadata) {
                return false;
            } else if (visitable instanceof PrismValue prismValue) {
                if (prismValue instanceof PrismContainerValue<?>) {
                    return true;
                } else {
                    removeValidationMetadata(prismValue);
                    return false;
                }
            } else {
                return visitable instanceof Item;
            }
        });
    }

    private static boolean hasValidation(@NotNull PrismValue value) {
        if (!value.hasValueMetadata()) {
            return false;
        }
        ValueMetadata vmc = value.getValueMetadata();
        if (vmc.hasNoValues()) {
            return false;
        }
        for (PrismContainerValue<Containerable> pcv : vmc.getValues()) {
            ValueMetadataType vmType = pcv.getRealValue();
            if (vmType != null && vmType.getValidation() != null) {
                return true;
            }
        }
        return false;
    }

    private static void setValidationOnValue(@NotNull PrismValue prismValue, @Nullable String reason) {
        ValueMetadata vmc = prismValue.getValueMetadata();
        ValueMetadataType target = null;
        for (PrismContainerValue<Containerable> pcv : vmc.getValues()) {
            ValueMetadataType vmType = pcv.getRealValue();
            if (vmType != null && vmType.getValidation() != null) {
                target = vmType;
                break;
            }
        }
        if (target == null) {
            // Create a dedicated metadata value for validation
            target = Objects.requireNonNull(vmc.createNewValue().getRealValue());
            target.setValidation(new ValidationMetadataType());
        }
        if (reason != null) {
            ValueMetadataTypeUtil.getOrCreateValidationMetadata(target).setReason(reason);
        } else {
            // ensure validation node exists even if reason is null
            ValueMetadataTypeUtil.getOrCreateValidationMetadata(target);
        }
    }

    /**
     * Removes validation metadata entries from the given PrismValue. If a metadata value becomes empty
     * after removing validation, the metadata value is removed as well. Returns true if anything was removed.
     */
    private static boolean removeValidationMetadata(@NotNull PrismValue prismValue) {
        ValueMetadata vmc = prismValue.getValueMetadata();
        if (vmc.hasNoValues()) {
            return false;
        }
        boolean changed = false;
        Iterator<PrismContainerValue<Containerable>> it = vmc.getValues().iterator();
        while (it.hasNext()) {
            PrismContainerValue<?> pcv = it.next();
            ValueMetadataType vmType = pcv.getRealValue();
            if (vmType == null) {
                continue;
            }
            if (vmType.getValidation() != null) {
                vmType.setValidation(null);
                changed = true;
                if (vmType.asPrismContainerValue().isEmpty()) {
                    it.remove();
                }
            }
        }
        if (changed && vmc.hasNoValues()) {
            vmc.clear();
        }
        return changed;
    }

}
