/*
 * Copyright (C) 2010-2025 Evolveum and contributors
 *
 * This work is dual-licensed under the Apache License 2.0
 * and European Union Public License. See LICENSE file for details.
 */

package com.evolveum.midpoint.schema.util;

import com.evolveum.midpoint.prism.*;

import com.evolveum.midpoint.prism.path.ItemPath;
import com.evolveum.midpoint.xml.ns._public.common.common_3.ProvenanceAcquisitionType;
import com.evolveum.midpoint.xml.ns._public.common.common_3.ProvenanceMetadataType;

import com.evolveum.midpoint.xml.ns._public.common.common_3.ServiceType;
import com.evolveum.midpoint.xml.ns._public.common.common_3.SystemObjectsType;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * Utility class for AI-related features.
 *
 * Values generated by AI are marked with metadata as described in {@link #createAiProvenanceMetadata()}.
 */
public class AiUtil {

    /**
     * Currently, we use the origin of {@link SystemObjectsType#ORIGIN_ARTIFICIAL_INTELLIGENCE} (with all other items null)
     * to indicate that the value was provided by AI.
     */
    private static final ProvenanceMetadataType AI_PROVENANCE_METADATA = createAiProvenanceMetadata();

    /** Convenience variant of {@link #markAsAiProvided(PrismValue)}. Marks the leaf nodes in the whole value. */
    public static <C extends Containerable> C markAsAiProvided(@NotNull C value) {
        markAsAiProvided(value.asPrismContainerValue());
        return value;
    }

    /** Convenience variant of {@link #markAsAiProvided(PrismValue)}. Marks the leaf nodes in items in the value (if present). */
    public static <C extends Containerable> C markAsAiProvided(@NotNull C containerable, ItemPath... paths) {
        for (ItemPath path : paths) {
            Item<?, ?> item = containerable.asPrismContainerValue().findItem(path);
            if (item != null) {
                for (var value : item.getValues()) {
                    markAsAiProvided(value);
                }
            }
        }
        return containerable;
    }

    /**
     * Marks all leaf values (i.e. property and reference values) as provided by AI. Uses value metadata to indicate that.
     * Does nothing if the value is {@code null}.
     *
     * The values themselves must be mutable!
     *
     * TODO The question is whether we should also mark the container values as AI-provided.
     */
    public static void markAsAiProvided(@Nullable PrismValue value) {
        if (value != null) {
            value.acceptVisitor(
                    visitable -> {
                        if (visitable instanceof ValueMetadata) {
                            return false; // we do not want to mark metadata itself
                        } else if (visitable instanceof PrismValue prismValue) {
                            if (visitable instanceof PrismContainerValue<?>) {
                                return true; // we want to drill down, but we do not want to mark the container value itself
                            } else {
                                ValueMetadataTypeUtil.getOrCreateMetadata(prismValue, AI_PROVENANCE_METADATA);
                                return false; // PPVs and PRVs have no children to visit
                            }
                        } else if (visitable instanceof Item) {
                            return true; // we want to visit the values
                        } else {
                            throw new IllegalArgumentException("Unexpected visitable type: " + visitable.getClass());
                        }
                    }
            );
        }
    }

    // TODO methods for clearing the AI mark

    /**
     * Returns {@code true} if the value is not {@code null} and is marked (at the root level) as provided by AI.
     */
    public static boolean isMarkedAsAiProvided(@Nullable PrismValue value) {
        return value != null
                && value.hasValueMetadata()
                && ValueMetadataTypeUtil.getMetadata(value, AI_PROVENANCE_METADATA) != null;
    }

    private static ProvenanceMetadataType createAiProvenanceMetadata() {
        var metadata = new ProvenanceMetadataType()
                .acquisition(new ProvenanceAcquisitionType()
                        .originRef(SystemObjectsType.ORIGIN_ARTIFICIAL_INTELLIGENCE.value(), ServiceType.COMPLEX_TYPE));
        metadata.freeze();
        return metadata;
    }
}
