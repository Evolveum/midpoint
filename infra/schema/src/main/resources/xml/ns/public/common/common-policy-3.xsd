<?xml version="1.0" encoding="UTF-8"?>

<!--
  ~ Copyright (c) 2010-2017 Evolveum
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<xsd:schema targetNamespace="http://midpoint.evolveum.com/xml/ns/public/common/common-3"
            xmlns:tns="http://midpoint.evolveum.com/xml/ns/public/common/common-3"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:a="http://prism.evolveum.com/xml/ns/public/annotation-3"
            xmlns:c="http://midpoint.evolveum.com/xml/ns/public/common/common-3"
            xmlns:t="http://prism.evolveum.com/xml/ns/public/types-3"
            xmlns:q="http://prism.evolveum.com/xml/ns/public/query-3"
            xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
            elementFormDefault="qualified"
            xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
            jaxb:extensionBindingPrefixes="xjc"
            jaxb:version="2.0">

    <xsd:annotation>
        <xsd:documentation>
            TODO
        </xsd:documentation>
    </xsd:annotation>

    <!-- Don't provide schemaLocation here, as it causes xjc to really contact the URIs (!) -->
    <xsd:import namespace="http://prism.evolveum.com/xml/ns/public/annotation-3"/>
    <xsd:import namespace="http://prism.evolveum.com/xml/ns/public/types-3"/>
    <xsd:import namespace="http://prism.evolveum.com/xml/ns/public/query-3"/>

    <xsd:include schemaLocation="http://midpoint.evolveum.com/xml/ns/public/common/common-core-3" />

    <xsd:complexType name="PolicyConstraintsType">
        <xsd:annotation>
            <xsd:documentation>
                Set of governance, risk management, compliance (GRC) and similar policy constraints
                that influence the identity model. These constraints act as triggers for the rules.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="exclusion" type="tns:ExclusionPolicyConstraintType" minOccurs="0" maxOccurs="unbounded"/>
            <xsd:element name="minAssignees" type="tns:MultiplicityPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Lowest number of objects that have this role assigned.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="maxAssignees" type="tns:MultiplicityPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Highest number of objects that have this role assigned.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="modification" type="tns:ModificationPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Modification of the object (add, modify, delete).
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="assignment" type="tns:AssignmentPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Assignment of this object, i.e. where this object is a
                        target of assignment or inducement that is being modified.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="timeValidity" type="tns:TimeValidityPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        A constraint that triggers when validity of an object, assignment, or basically any time-sensitive
                        item (e.g. password) is about to end.

						Note: in 3.6, this constraint is _not_ evaluated during projector run. It is meant to be evaluated
						by a special task. In the future we plan to bring evaluation of this constraint into standard
						projector/clockwork processing.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="situation" type="tns:PolicySituationPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Occurrence of the policy situation within an object.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <!-- TODO: notifications, recertification, default remediation -->
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:long" use="optional"/>
    </xsd:complexType>

    <xsd:complexType name="AbstractPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Basic data structure for all policy constraints.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="name" type="xsd:string" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Identifier of the constraint. It is used when midPoint
                        needs to refer to a specific constraint, e.g. in order
                        to record exception.
                        This element is formally specified as optional, mostly
                        due to the compatibility reasons. But it
                        has to be provided in order for some functionality to
                        work correctlry.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.5</a:since>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="tns:description" minOccurs="0"/>
            <xsd:element name="enforcement" type="tns:PolicyConstraintEnforcementType" minOccurs="0" default="enforce">
                <xsd:annotation>
                    <xsd:appinfo>
                        <a:deprecated>true</a:deprecated>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <!-- TODO: remediation -->
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:long" use="optional"/>
    </xsd:complexType>
    <xsd:element name="abstractPolicyConstraint" type="tns:AbstractPolicyConstraintType" />

    <xsd:complexType name="ExclusionPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Container that defines exclusion of entities (e.g. roles).
                It is a part of Segregation of Duties (SoD) mechanism.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="targetRef" type="tns:ObjectReferenceType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
					        	<p>
	                                Target of exclusion. The object defining this "exclustion" and
	                                the object defined as target cannot be assigned at the same time.
	                                Filter in the reference may be used to dynamically exclude broader
	                                range of roles - assuming that runtime resolution is used.
	                            </p>
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="policy" type="tns:ExclusionPolicyType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:appinfo>
                                <a:deprecated>true</a:deprecated>
                            </xsd:appinfo>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="exclusionPolicyConstraint" type="tns:ExclusionPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="MultiplicityPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Constraint on multiplicity of assigned objects.
				(Other multiplicity requirements will be probably treated in separate constraints, like "constraint that
				restricts value(s) of given item, based on a set of conditions that must be met".)
            </xsd:documentation>
            <xsd:appinfo>
				<a:container/>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="multiplicity" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                Numeric value or string "unbounded".
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="relation" type="xsd:QName" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Relation(s) to which this constraint applies. All of these relations must match
								the defined multiplicity. If no relation is present, org:default (i.e. null) is assumed.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
					<!-- TODO something like "assigned" vs. "effective" - i.e. if we watch assignments created
					or assignments that are actually "alive" (i.e. enabled and with condition = true) -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="minAssigneesPolicyConstraint" type="tns:MultiplicityPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />
    <xsd:element name="maxAssigneesPolicyConstraint" type="tns:MultiplicityPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="ModificationPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Constraint that triggers the rule on object modification, addition or deletion.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="operation" type="t:ChangeTypeType"  minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies the operation(s) for which this constraints should be triggered.
                                If not specified then it will be triggered for all operations.
                                This defines the object operation (add/modify/delete of the entire object).
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="item" type="t:ItemPathType"  minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specification of items that must be modified (all of them) in order for this
                                constraint be triggered. If no items are specified then any modification will
                                trigger this constraint.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="modificationPolicyConstraint" type="tns:ModificationPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="AssignmentPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Constraint that triggers the rule when the object is assigned.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="operation" type="t:ModificationTypeType"  minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies the operation(s) for which this constraints should be triggered.
                                If not specified then it will be triggered for all operations.
                                This defines the object modification operation (add/replace/delete of the specific assignment).
                                In case that new object is added then all assignments in the object are considered to
                                be added. The case of object deletion does not make sense here.

                                Currently supported are ADD and DELETE operations.
								REPLACE (meaning MODIFY?) is not supported yet.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="relation" type="xsd:QName"  minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                This policy only applies to relations of the specified type. The value
                                of this element is compared to the relation of the targetRef relation
                                in the assignment/inducement. If not specified then this policy only
                                applies to the null (default) relation. If all relations need to be
                                affected by this policy then the special value of "any" should be specified
                                in this element.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <!--<xsd:element name="targetType" type="xsd:QName"  minOccurs="0" maxOccurs="unbounded">-->
                        <!--<xsd:annotation>-->
                            <!--<xsd:documentation>-->
                                <!--This policy only applies to targets of the specified type.-->
                            <!--</xsd:documentation>-->
							<!--<xsd:appinfo>-->
								<!--<a:since>3.6</a:since>-->
							<!--</xsd:appinfo>-->
                        <!--</xsd:annotation>-->
                    <!--</xsd:element>-->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="assignmentPolicyConstraint" type="tns:AssignmentPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="TimeValidityPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                A constraint that triggers when validity of an object, assignment, or basically any time-sensitive
                item (e.g. password) is about to end.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.6</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="item" type="t:ItemPathType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The item whose validity is to be checked. If not specified, activation/validTo is assumed.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="assignment" type="xsd:boolean" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                If set to true, validity of assignments of the relevant object are to be checked, not
                                items of the object itself. So, for example, if you want to send notifications before validity of
                                assignments to roles A, B, C expire, you'd need to attach a policy rule with this constraint
                                having assignment=true to roles A, B, and C.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="activateOn" type="xsd:duration" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                When will this policy constraint activate (trigger)? If not specified, activation will occur
                                on the moment of validity change. Specify negative durations if you need to activate the trigger
                                before that moment; and positive ones is the trigger should be activated after that.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="deactivateOn" type="xsd:duration" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                When will be this policy constraint deactivated? If not specified, it will be active forever.
                                Specify negative durations if you need to activate the trigger before the moment of validity
                                change; and positive ones is the trigger should be deactivated after that.

                                If not specified, the trigger will be active forever (TODO ok? or only until validTo occurs?)
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="timeValidityPolicyConstraint" type="tns:TimeValidityPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="PolicySituationPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Constraint that triggers the rule when the object is in a given policy situation(s).
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.6</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="situation" type="xsd:anyURI"  minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies the policy situation URI(s) to look for.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <!-- TODO some more complex expressions (at least "and / or"; or something like this) -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="situationPolicyConstraint" type="tns:PolicySituationPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:simpleType name="PolicyConstraintEnforcementType">
        <xsd:annotation>
            <xsd:documentation>
                Enumeration of exclustion policy enforcement types.
            </xsd:documentation>
            <xsd:appinfo>
                <jaxb:typesafeEnumClass/>
                <a:deprecated>true</a:deprecated>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="enforce">
                <xsd:annotation>
                    <xsd:documentation>
                        Strictly enforce the policy. Any operation that attempts to violate
                        the policy will fail.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="ENFORCE"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="remediate">
                <xsd:annotation>
                    <xsd:documentation>
                        The operation that attempts to violate the policy will be suspended.
                        Remediation action will take place. This may be used e.g. to approve the
                        exceptions from the policy.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="REMEDIATE"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="report">
                <xsd:annotation>
                    <xsd:documentation>
                        Policy will not be enforced in any way, the violations will only
                        be reported.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="REPORT"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="ExclusionPolicyType">
        <xsd:annotation>
            <xsd:documentation>
                Enumeration of exclusion policy enforcement types.
            </xsd:documentation>
            <xsd:appinfo>
                <jaxb:typesafeEnumClass/>
                <a:deprecated>true</a:deprecated>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="enforce">
                <xsd:annotation>
                    <xsd:documentation>
                        Enforce the policy. Excluded entities must not be assigned together.
                        Attempt to do so will result in an error.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="ENFORCE"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="approve">
                <xsd:annotation>
                    <xsd:documentation>
                        Exceptions to the policy are possible but are subject to an approval.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="APPROVE"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="report">
                <xsd:annotation>
                    <xsd:documentation>
                        Policy will not be enforced in any way, the violations will only
                        be reported.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="REPORT"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="PolicyActionsType">
        <xsd:annotation>
            <xsd:documentation>
                Actions that are executed as reactions to triggered policy rules.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="enforcement" type="tns:EnforcementPolicyActionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        Enforcement action. This action stops the operation and results with the error.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="approval" type="tns:ApprovalPolicyActionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        Approval action. The operation will be suspended and the approval workflow will be started.
                        If the workflow ends with success the operation will proceed. If the workflow ends with
                        an error the operation will also end with an error.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="remediation" type="tns:RemediationPolicyActionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        Remediation action. The operation will proceed. A workflow will be started to remediate the
                        result of the operation afte the operation is done.
                        This action is ideal for operations that cannot be stopped, e.g. when manager
                        of an organizational unit is deleted because he quits the job.
                        This action starts a workflow. Therefore it is ideal for actions that are not frequent but
                        that require immediate attention. E.g. missing manager for organizational unit.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="prune" type="tns:PrunePolicyActionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        Prune action. The operation will proceed. Any other assignments that are in conflict with
                        this assignment that triggered the rule will be "pruned": they will be removed. The removal
                        of the conflicting assignments is automatic and silent. It will not be subject to approvals
                        or other policy contratints.
                        This mechanism can be used for example to implement set of roles where only one of the roles
                        can be assigned at a time.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="certification" type="tns:CertificationPolicyActionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        Certification action. The operation will proceed. The object will be scheduled for
                        a certification campaign after the operation is done.
                        This action works with certification campaign. Therefore it is ideal for actions that are frequent
                        and can occur on large number of objects. The campaign is an efficient method how to handle mass
                        decisions. However it mat not be started immediately.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="notification" type="tns:NotificationPolicyActionType" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        Notification action. The operation will proceed. Notifications are sent at the end of the
                        operation.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:long" use="optional"/>
    </xsd:complexType>

    <xsd:complexType name="PolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                Common supertype for policy actions.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="name" type="xsd:string" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        <p>
                            Name for the action. It is used for logging and other diagnostic purposes.
                        </p>
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="description" type="xsd:string" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        <p>
                            Free-form description (e.g. comments about the action purpose)
                        </p>
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="EnforcementPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                Enforcement action. This action stops the operation and results with the error.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <!-- Empty for now.
						 TODO: later add type of error and message -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="ApprovalPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                Approval action. The operation will be suspended and the approval workflow will be started.
                If the workflow ends with success the operation will proceed. If the workflow ends with
                an error the operation will also end with an error.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <xsd:element name="compositionStrategy" type="c:ApprovalCompositionStrategyType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                How should be this approval policy action composed with other ones that
                                might be related to the same item (object or assignment)?
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:choice>
                        <xsd:sequence>
                            <xsd:element name="approverRelation" type="xsd:QName" minOccurs="0" maxOccurs="unbounded">
                                <xsd:annotation>
                                    <xsd:documentation>
                                        <p>
                                            What relation(s) to use when determining approvers? E.g. "approver", "owner",
                                            "securityApprover", and so on.
                                        </p>
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="approverRef" type="c:ObjectReferenceType" minOccurs="0" maxOccurs="unbounded">
                                <xsd:annotation>
                                    <xsd:documentation>
                                        <p>
                                            Direct enumeration of the approvers to be used.
                                            May be used with approverRelation and approverExpression element(s).
                                        </p>
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="approverExpression" type="c:ExpressionType" minOccurs="0" maxOccurs="unbounded">
                                <xsd:annotation>
                                    <xsd:documentation>
                                        <p>
                                            Expression(s) that yield approvers to be used. If specified, the expression(s) are evaluated and
                                            the result is used as a set of approvers (UserType, OrgType, RoleType, or any combination of them).
                                            May be used with approverRelation and approverRef element(s).
                                        </p>
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:sequence>
                        <xsd:element name="approvalSchema" type="c:ApprovalSchemaType" minOccurs="0" maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation>
                                    <p>
                                        More complex (multi-stages) approval schema.
                                    </p>
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="approvalProcess" type="xsd:string"
                                     minOccurs="0" maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation>
                                    <p>
                                        Name of custom approval process.
                                    </p>
                                    <p>
                                        THIS PROPERTY (approvalProcess) IS NOT SUPPORTED YET.
                                    </p>
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:element name="automaticallyApproved" type="c:ExpressionType" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                <p>
                                    Condition specifying when the approval is automatically granted (e.g.
                                    "user is from Board of Directors"). This is an expression that should yield a
                                    boolean value.

                                    DEPRECATED. Use automaticallyCompleted in approval level definition.
                                </p>
                            </xsd:documentation>
                            <xsd:appinfo>
                                <a:deprecated>true</a:deprecated>
                                <a:deprecatedSince>3.6</a:deprecatedSince>
                            </xsd:appinfo>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="ApprovalCompositionStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                Prescribes how individual approval requirements should be composed into overall approval schema.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="order" type="xsd:int" minOccurs="0"/>
            <xsd:element name="exclusive" type="xsd:boolean" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        If set to true, this fragment might be the only one with this particular order number.
						(Other fragments could be merged into it, but in "mergeIntoOrder" mode. TODO TODO TODO)
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="mergeable" type="xsd:boolean" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        If set to true, this schema fragment is eligible to merging with other fragments of the same order.
                        (Non-mergeable fragments with the same order are ordered randomly. Mergeable fragments must have
                        order filled-in.)

						Mergeable fragments must have "order" attribute set.

                        Restrictions on merging schema fragments:
                        1) Mergeable fragments must contain exactly one stage. It is merged with the stage(s) of the other
                        fragment(s) without any further considerations (e.g. regarding stage order or name or whatever).
                        2) It is expected that single policy rule triggered all the fragments that are being merged. So
                        we consider any of these rules.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="mergeIntoOrder" type="xsd:int" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Which fragments should this one be merged with. This is mutually exclusive with the "order" attribute.
						If order is set, it is not possible to specify mergeIntoOrder. Both fragments with the same order are
						considered "equal". This can be used e.g. to provide a different set of approvers (for the given stage).
						If mergeIntoOrder is set (usually with multiple values), this fragment is considered as an augmentation
						of other ones. This can be used e.g. to provide an escalation or notification strategy, custom form information, etc.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element><xsd:element name="mergeIntoAll" type="xsd:boolean" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Indicates that this fragment is to be merged into all the other "base" fragments.
						This is mutually exclusive with the "order" and "mergeIntoOrder" attributes.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="mergePriority" type="xsd:int" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Provides an information about order in which this fragment is merged (lower numbers are processed before higher ones).
					</xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="mergeOverwriting" type="xsd:QName" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        If stage B is being merged into existing stage A (i.e. mergeOrder B is greater mergeOrder A),
                        all non-null values of B will be added to values of A; overwriting them in case of single-valued items.
                        For items marked as "mergeOverwriting", the actual values of B (even those that are null or empty)
                        overwrite those in A.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="RemediationPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                TODO
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <!-- TODO -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="PrunePolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                TODO
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <!-- TODO -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="CertificationPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                TODO
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <xsd:element name="definitionRef" type="c:ObjectReferenceType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                <p>
                                    Certification definition(s) to be started as part of the action execution.
                                </p>
                            </xsd:documentation>
                            <xsd:appinfo>
                                <a:objectReferenceTargetType>tns:AccessCertificationDefinitionType</a:objectReferenceTargetType>
                                <a:since>3.6</a:since>
                            </xsd:appinfo>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="NotificationPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                TODO
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <!-- TODO -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="PolicyExceptionType">
        <xsd:annotation>
            <xsd:documentation>
                Recorded exception from a policy rule. The exceptions that are approved are
                recoded here to avoid re-evaluating and re-approving them all the time.
                This is EXPERIMENTAL functionality. It is likely to change in the near future.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="ruleName" type="xsd:string" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        <p>
                            Name for the rule for which this is an exception.
                        </p>
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="policySituation" type="xsd:anyURI" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        <p>
                            Policy situation for which this is an exception.
                        </p>
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <!-- TODO: validity? -->
            <xsd:element name="metadata" type="tns:MetadataType" minOccurs="0"/>
        </xsd:sequence>
    </xsd:complexType>

</xsd:schema>
