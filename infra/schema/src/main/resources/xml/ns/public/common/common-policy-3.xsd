<?xml version="1.0" encoding="UTF-8"?>

<!--
  ~ Copyright (c) 2010-2017 Evolveum
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<xsd:schema targetNamespace="http://midpoint.evolveum.com/xml/ns/public/common/common-3"
            xmlns:tns="http://midpoint.evolveum.com/xml/ns/public/common/common-3"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:a="http://prism.evolveum.com/xml/ns/public/annotation-3"
            xmlns:c="http://midpoint.evolveum.com/xml/ns/public/common/common-3"
            xmlns:t="http://prism.evolveum.com/xml/ns/public/types-3"
            xmlns:q="http://prism.evolveum.com/xml/ns/public/query-3"
            xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
            elementFormDefault="qualified"
            xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
            jaxb:extensionBindingPrefixes="xjc"
            jaxb:version="2.0">

    <xsd:annotation>
        <xsd:documentation>
            TODO
        </xsd:documentation>
    </xsd:annotation>

    <!-- Don't provide schemaLocation here, as it causes xjc to really contact the URIs (!) -->
    <xsd:import namespace="http://prism.evolveum.com/xml/ns/public/annotation-3"/>
    <xsd:import namespace="http://prism.evolveum.com/xml/ns/public/types-3"/>
    <xsd:import namespace="http://prism.evolveum.com/xml/ns/public/query-3"/>

    <xsd:include schemaLocation="http://midpoint.evolveum.com/xml/ns/public/common/common-core-3" />

    <xsd:complexType name="PolicyConstraintsType">
        <xsd:annotation>
            <xsd:documentation>
                Set of governance, risk management, compliance (GRC) and similar policy constraints
                that influence the identity model. These constraints act as triggers for the rules.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
            </xsd:appinfo>
        </xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="tns:AbstractPolicyConstraintType">
				<xsd:sequence>
					<xsd:element name="objectState" type="tns:StatePolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Particular state of the object, described by a filter or an expression.
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.7</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="assignmentState" type="tns:StatePolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Particular state of an assignment, described by a filter or an expression.
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.7</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="hasAssignment" type="tns:HasAssignmentPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								The focus has assignment(s) of given object(s).
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.7</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="hasNoAssignment" type="tns:HasAssignmentPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								The focus has no assignment(s) of given object(s).
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.7</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="exclusion" type="tns:ExclusionPolicyConstraintType" minOccurs="0" maxOccurs="unbounded"/>
					<xsd:element name="minAssignees" type="tns:MultiplicityPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Actual number of objects that have this role assigned is lower than prescribed value.
								(The constraint should be perhaps named minAssigneesViolation.)
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="maxAssignees" type="tns:MultiplicityPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Actual number of objects that have this role assigned is higher than prescribed value.
								(The constraint should be perhaps named maxAssigneesViolation.)
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="objectMinAssigneesViolation" type="tns:MultiplicityPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Actual number of objects that have this object (e.g. role) assigned is lower than prescribed value.
								This is the same as minAssignees, but indicates that the constraint should be evaluated against an object
								when evaluating object constraints. HIGHLY EXPERIMENTAL
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="objectMaxAssigneesViolation" type="tns:MultiplicityPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Actual number of objects that have this object (e.g. role) assigned is higher than prescribed value.
								This is the same as minAssignees, but indicates that the constraint should be evaluated against an object
								when evaluating object constraints. HIGHLY EXPERIMENTAL
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="modification" type="tns:ModificationPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Modification of the object (add, modify, delete).
								(This constraint should be perhaps named objectModification.)
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="assignment" type="tns:AssignmentModificationPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Modification of an assignment, i.e. where this object is a target of assignment that is being modified.
								(This constraint should be perhaps named assignmentModification.)
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="objectTimeValidity" type="tns:TimeValidityPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								A constraint that triggers when validity of an object or any of its time-sensitive
								items (e.g. password) is about to end.
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.6</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="assignmentTimeValidity" type="tns:TimeValidityPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								A constraint that triggers when validity of an assignment or any of its time-sensitive
								items (e.g. password) is about to end.
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.6</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="situation" type="tns:PolicySituationPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Occurrence of the policy situation within an object or an assignment.
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="and" type="tns:PolicyConstraintsType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Constraints that must all apply. (But note that if there are more values of this item,
								they are interpreted according to the enclosing operator.)
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.7</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="or" type="tns:PolicyConstraintsType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Constraints from which at least one must apply. (But note that if there are more values of this item,
								they are interpreted according to the enclosing operator.)
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.7</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="not" type="tns:PolicyConstraintsType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								The inner constraint must not apply.
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.7</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="transition" type="tns:TransitionPolicyConstraintType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								Specifies how the inner constraints are to be evaluated with regards to operation start and end state.
								May not include any transitional constraints itself!
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.7</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="ref" type="tns:PolicyConstraintReferenceType" minOccurs="0" maxOccurs="unbounded">
						<xsd:annotation>
							<xsd:documentation>
								References another policy constraint e.g. by its name.
								The referenced constraint must be present as part of policy rules gathered for a given
								assignment or object. Also, all declared global constraints are available for referencing,
								regardless of which objects they are attached to or whether they are active or not.
							</xsd:documentation>
							<xsd:appinfo>
								<a:since>3.7</a:since>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
        <!--<xsd:attribute name="id" type="xsd:long"/>--> <!-- already present in the abstract constraint -->
    </xsd:complexType>

    <xsd:complexType name="PolicyConstraintReferenceType">
        <xsd:annotation>
            <xsd:documentation>
                References another policy constraint.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
				<a:since>3.7</a:since>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="name" type="xsd:string" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Name of the constraint referenced.
                    </xsd:documentation>
                </xsd:annotation>
				<!-- parameters, if the referenced constraint is a parametrized one -->
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:long"/>
    </xsd:complexType>

    <xsd:complexType name="AbstractPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Basic data structure for all policy constraints.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="name" type="xsd:string" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Identifier of the constraint. It is used when midPoint
                        needs to refer to a specific constraint, e.g. in order
                        to record exception.
                        This element is formally specified as optional, mostly
                        due to the compatibility reasons. But it
                        has to be provided in order for some functionality to
                        work correctly.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.5</a:since>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="tns:description" minOccurs="0"/>
			<xsd:element name="presentation" type="tns:PolicyConstraintPresentationType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						How should be triggering of this constraint presented, e.g. in enforcement messages,
						in approvals, in certification, in notifications, etc.
					</xsd:documentation>
					<xsd:appinfo>
						<a:since>3.7</a:since>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="policySituation" type="xsd:anyURI" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						Policy situation that is the result when this constraint is triggered.
						TODO specify the relation to policySituation defined at the level of policy rule.
					</xsd:documentation>
					<xsd:appinfo>
						<a:since>3.7</a:since>
						<a:experimental>true</a:experimental>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="expectedUse" type="tns:PolicyConstraintExpectedUseType" minOccurs="0" maxOccurs="unbounded">
				<xsd:annotation>
					<xsd:documentation>
						How is this constraint to be used? E.g. also for reporting or for certification? This determines
						if its triggers and/or related policy situation should be stored into repository.
						EXPERIMENTAL
					</xsd:documentation>
					<xsd:appinfo>
						<a:since>3.7</a:since>
						<a:experimental>true</a:experimental>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
            <xsd:element name="storageCompaction" type="tns:PolicyTriggerStorageCompactionType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						If triggers are to be stored, what level of details should be preserved?
						EXPERIMENTAL
					</xsd:documentation>
					<xsd:appinfo>
						<a:since>3.7</a:since>
						<a:experimental>true</a:experimental>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
            <xsd:element name="enforcement" type="tns:PolicyConstraintEnforcementType" minOccurs="0" default="enforce">
                <xsd:annotation>
                    <xsd:appinfo>
                        <a:deprecated>true</a:deprecated>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:long"/>
    </xsd:complexType>
    <xsd:element name="abstractPolicyConstraint" type="tns:AbstractPolicyConstraintType" />

	<xsd:complexType name="PolicyConstraintPresentationType">
		<xsd:annotation>
			<xsd:documentation>
				How should be triggering of this constraint presented, e.g. in enforcement messages,
				in approvals, in certification, in notifications, etc.
			</xsd:documentation>
			<xsd:appinfo>
				<a:container/>
				<a:since>3.7</a:since>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element name="message" type="tns:LocalizableMessageTemplateType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						Message to be conveyed to the user.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="shortMessage" type="tns:LocalizableMessageTemplateType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						Very short message describing the situation. Could be used for e.g. notification messages subject, approval process or work item names.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="longMessage" type="tns:LocalizableMessageTemplateType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						Long, documentation-like explanation of the rule.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<!-- todo something like GUI component id/type -->
			<xsd:element name="final" type="xsd:boolean" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						If set to true, no embedded triggers will be presented. Use for hiding constraints that are
						to be considered too technical to be shown to user. EXPERIMENTAL
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="hidden" type="xsd:boolean" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						If set to true, this trigger will be excluded from presentation. EXPERIMENTAL
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
		</xsd:sequence>
		<xsd:attribute name="id" type="xsd:long"/>
	</xsd:complexType>
	<xsd:element name="policyConstraintPresentation" type="tns:PolicyConstraintPresentationType" />

	<xsd:simpleType name="PolicyConstraintExpectedUseType">
		<xsd:annotation>
			<xsd:documentation>
				How is this constraint to be used? E.g. also for reporting or for certification? This determines
				if its triggers and/or related policy situation should be stored into repository.
				EXPERIMENTAL
			</xsd:documentation>
			<xsd:appinfo>
				<jaxb:typesafeEnumClass/>
				<a:deprecated>true</a:deprecated>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="certification">
				<xsd:annotation>
					<xsd:documentation>
						Situation and triggers will be stored.
					</xsd:documentation>
					<xsd:appinfo>
						<jaxb:typesafeEnumMember name="CERTIFICATION"/>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="briefReport">
				<xsd:annotation>
					<xsd:documentation>
						Situation will be stored but no triggers.
					</xsd:documentation>
					<xsd:appinfo>
						<jaxb:typesafeEnumMember name="BRIEF_REPORT"/>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="fullReport">
				<xsd:annotation>
					<xsd:documentation>
						Situation and triggers will be stored.
					</xsd:documentation>
					<xsd:appinfo>
						<jaxb:typesafeEnumMember name="FULL_REPORT"/>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="PolicyTriggerStorageCompactionType">
		<xsd:annotation>
			<xsd:documentation>
				If triggers are to be stored, what level of details should be preserved?
				EXPERIMENTAL
			</xsd:documentation>
			<xsd:appinfo>
				<jaxb:typesafeEnumClass/>
				<a:deprecated>true</a:deprecated>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="full">
				<xsd:annotation>
					<xsd:documentation>
						Only message and short message will be stored.
					</xsd:documentation>
					<xsd:appinfo>
						<jaxb:typesafeEnumMember name="FULL"/>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="normal">
				<xsd:annotation>
					<xsd:documentation>
						Whole triggers will be stored. (But only those that are directly marked with expectedUse property.)
					</xsd:documentation>
					<xsd:appinfo>
						<jaxb:typesafeEnumMember name="NORMAL"/>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="none">
				<xsd:annotation>
					<xsd:documentation>
						Whole triggers will be stored, including subtriggers.
					</xsd:documentation>
					<xsd:appinfo>
						<jaxb:typesafeEnumMember name="NONE"/>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

    <xsd:complexType name="ExclusionPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Container that defines exclusion of entities (e.g. roles).
                It is a part of Segregation of Duties (SoD) mechanism.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="targetRef" type="tns:ObjectReferenceType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
					        	<p>
	                                Target of exclusion. The object defining this "exclusion" and
	                                the object defined as target cannot be assigned at the same time.
	                                Filter in the reference may be used to dynamically exclude broader
	                                range of roles - assuming that runtime resolution is used.
	                            </p>
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="policy" type="tns:ExclusionPolicyType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:appinfo>
                                <a:deprecated>true</a:deprecated>
                            </xsd:appinfo>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="exclusionPolicyConstraint" type="tns:ExclusionPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="MultiplicityPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Constraint on multiplicity of assigned objects.
				(Other multiplicity requirements will be probably treated in separate constraints, like "constraint that
				restricts value(s) of given item, based on a set of conditions that must be met".)
            </xsd:documentation>
            <xsd:appinfo>
				<a:container/>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="multiplicity" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                Numeric value or string "unbounded".
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="relation" type="xsd:QName" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Relation(s) to which this constraint applies. All of these relations must match
								the defined multiplicity. If no relation is present, org:default (i.e. null) is assumed.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
					<!-- TODO something like "assigned" vs. "effective" - i.e. if we watch assignments created
					or assignments that are actually "alive" (i.e. enabled and with condition = true) -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="minAssigneesPolicyConstraint" type="tns:MultiplicityPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />
    <xsd:element name="maxAssigneesPolicyConstraint" type="tns:MultiplicityPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="ModificationPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Constraint that triggers the rule on object modification, addition or deletion.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="operation" type="t:ChangeTypeType"  minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies the operation(s) for which this constraints should be triggered.
                                If not specified then it will be triggered for all operations.
                                This defines the object operation (add/modify/delete of the entire object)
								or assignment operation (add/modify/delete of the given assignment).
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="item" type="t:ItemPathType"  minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specification of items that must be modified (all of them) in order for this
                                constraint be triggered. If no items are specified then any modification will
                                trigger this constraint.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="modificationPolicyConstraint" type="tns:ModificationPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="AssignmentModificationPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Constraint that triggers the rule when the object is assigned.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:ModificationPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="relation" type="xsd:QName"  minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                This constraint only applies to relations of the specified type. The value
                                of this element is compared to the relation of the targetRef relation
                                in the assignment. If not specified then this policy only
                                applies to the null (default) relation. If all relations need to be
                                affected by this policy then the special value of "any" should be specified
                                in this element.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <!--<xsd:element name="targetType" type="xsd:QName"  minOccurs="0" maxOccurs="unbounded">-->
                        <!--<xsd:annotation>-->
                            <!--<xsd:documentation>-->
                                <!--This policy only applies to targets of the specified type.-->
                            <!--</xsd:documentation>-->
							<!--<xsd:appinfo>-->
								<!--<a:since>3.6</a:since>-->
							<!--</xsd:appinfo>-->
                        <!--</xsd:annotation>-->
                    <!--</xsd:element>-->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="assignmentModificationPolicyConstraint" type="tns:AssignmentModificationPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="HasAssignmentPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Constraint that triggers when the focus has given assignment(s).
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.7</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="targetRef" type="c:ObjectReferenceType">
                        <xsd:annotation>
                            <xsd:documentation>
                                Assignment target to be matched. Might be dynamic (with a resolution time of "run"), just
                                like the one in exclusion constraint. If a relation here is specified, it takes precedence
                                over "relation" item in this constraint.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
					<xsd:element name="direct" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								If true the assignment to given target must be direct. If false, it must be indirect (induced).
								If not specified, it might be either direct or indirect. But in all cases it must be of the order
								one, i.e. metaroles are not considered.
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
    				<xsd:element name="enabled" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								If true the assignment to given target must be effectively enabled. If false, it must be present
								but effectively disabled (beware, the behavior of midPoint for disabled indirect assignments may
								be fragile). If not specified, the effective status is not considered.
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
                    <xsd:element name="relation" type="xsd:QName" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                This policy only applies to relations of the specified type. (Provided that the relation
                                is not set in the targetRef.) The value of this element is compared to the relation of the
                                targetRef relation in the assignment/inducement. If not specified then this policy only
                                applies to the null (default) relation. If all relations need to be affected by this policy
                                then the special value of "any" should be specified in this element or in the targetRef element.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
				</xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="hasAssignmentPolicyConstraint" type="tns:HasAssignmentPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />
    <xsd:element name="hasNoAssignmentPolicyConstraint" type="tns:HasAssignmentPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="TimeValidityPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                A constraint that triggers when validity of an object, assignment, or basically any time-sensitive
                item (e.g. password) is about to end.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.6</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="item" type="t:ItemPathType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The item whose validity is to be checked. If not specified, activation/validTo is assumed.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="assignment" type="xsd:boolean" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                If set to true, validity of assignments of the relevant object are to be checked, not
                                items of the object itself. So, for example, if you want to send notifications before validity of
                                assignments to roles A, B, C expire, you'd need to attach a policy rule with this constraint
                                having assignment=true to roles A, B, and C.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="activateOn" type="xsd:duration" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                When will this policy constraint activate (trigger)? If not specified, activation will occur
                                on the moment of validity change. Specify negative durations if you need to activate the trigger
                                before that moment; and positive ones if the trigger should be activated after that.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="deactivateOn" type="xsd:duration" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                When will be this policy constraint deactivated? If not specified, it will be active forever.
                                Specify negative durations if you need to activate the trigger before the moment of validity
                                change; and positive ones is the trigger should be deactivated after that.

                                If not specified, the trigger will be active forever (TODO ok? or only until validTo occurs?)
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="timeValidityPolicyConstraint" type="tns:TimeValidityPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="StatePolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                A constraint that triggers when a object or assignment is in a given state.
                If both filter and expressions are specified, both must be true in order for constraint to be triggered.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.7</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="filter" type="q:SearchFilterType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Filter that is to be used to determine the state.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="expression" type="tns:ExpressionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Expression that is to be used to determine the state.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="objectStatePolicyConstraintType" type="tns:StatePolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />
    <xsd:element name="assignmentStatePolicyConstraintType" type="tns:StatePolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="PolicySituationPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
                Constraint that triggers the rule when the object is in a given policy situation(s).
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.6</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="situation" type="xsd:anyURI"  minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies the policy situation URI(s) to look for.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <!-- TODO some more complex expressions (at least "and / or"; or something like this) -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="situationPolicyConstraint" type="tns:PolicySituationPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:complexType name="TransitionPolicyConstraintType">
        <xsd:annotation>
            <xsd:documentation>
				Specifies how the inner constraints are to be evaluated with regards to operation start and end state.
				May not include any transitional constraints itself!
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:since>3.7</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:AbstractPolicyConstraintType">
                <xsd:sequence>
                    <xsd:element name="stateBefore" type="xsd:boolean" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Expected inner constraint state before the operation.
								True means the constraint must evaluate to true. False means the constraint must evaluate to false.
								Unspecified means the constraint is not checked before the operation.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="stateAfter" type="xsd:boolean" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Expected inner constraint state after the operation.
								True means the constraint must evaluate to true. False means the constraint must evaluate to false.
								Unspecified means the constraint is not checked after the operation.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
					<xsd:element name="constraints" type="tns:PolicyConstraintsType">
                        <xsd:annotation>
                            <xsd:documentation>
                                Non-transitional policy constraints to be evaluated.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="transitionPolicyConstraint" type="tns:TransitionPolicyConstraintType" substitutionGroup="tns:abstractPolicyConstraint" />

    <xsd:simpleType name="PolicyConstraintEnforcementType">
        <xsd:annotation>
            <xsd:documentation>
                Enumeration of exclusion policy enforcement types.
            </xsd:documentation>
            <xsd:appinfo>
                <jaxb:typesafeEnumClass/>
                <a:deprecated>true</a:deprecated>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="enforce">
                <xsd:annotation>
                    <xsd:documentation>
                        Strictly enforce the policy. Any operation that attempts to violate
                        the policy will fail.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="ENFORCE"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="remediate">
                <xsd:annotation>
                    <xsd:documentation>
                        The operation that attempts to violate the policy will be suspended.
                        Remediation action will take place. This may be used e.g. to approve the
                        exceptions from the policy.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="REMEDIATE"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="report">
                <xsd:annotation>
                    <xsd:documentation>
                        Policy will not be enforced in any way, the violations will only
                        be reported.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="REPORT"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="ExclusionPolicyType">
        <xsd:annotation>
            <xsd:documentation>
                Enumeration of exclusion policy enforcement types.
            </xsd:documentation>
            <xsd:appinfo>
                <jaxb:typesafeEnumClass/>
                <a:deprecated>true</a:deprecated>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="enforce">
                <xsd:annotation>
                    <xsd:documentation>
                        Enforce the policy. Excluded entities must not be assigned together.
                        Attempt to do so will result in an error.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="ENFORCE"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="approve">
                <xsd:annotation>
                    <xsd:documentation>
                        Exceptions to the policy are possible but are subject to an approval.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="APPROVE"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="report">
                <xsd:annotation>
                    <xsd:documentation>
                        Policy will not be enforced in any way, the violations will only
                        be reported.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <jaxb:typesafeEnumMember name="REPORT"/>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="PolicyActionsType">
        <xsd:annotation>
            <xsd:documentation>
                Actions that are executed as reactions to triggered policy rules.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container/>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="enforcement" type="tns:EnforcementPolicyActionType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Enforcement action. This action stops the operation and results with the error.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="approval" type="tns:ApprovalPolicyActionType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Approval action(s). The operation will be suspended and the approval workflow will be started.
                        If the workflow ends with success the operation will proceed. If the workflow ends with
                        an error the operation will also end with an error.

						More approval actions can be specified. They will be eventually merged into one approval process.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="remediation" type="tns:RemediationPolicyActionType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Remediation action. The operation will proceed. A workflow will be started to remediate the
                        result of the operation after the operation is done.
                        This action is ideal for operations that cannot be stopped, e.g. when manager
                        of an organizational unit is deleted because he quits the job.
                        This action starts a workflow. Therefore it is ideal for actions that are not frequent but
                        that require immediate attention. E.g. missing manager for organizational unit.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="prune" type="tns:PrunePolicyActionType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Prune action. The operation will proceed. Any other assignments that are in conflict with
                        this assignment that triggered the rule will be "pruned": they will be removed. The removal
                        of the conflicting assignments is automatic and silent. It will not be subject to approvals
                        or other policy constraints.
                        This mechanism can be used for example to implement set of roles where only one of the roles
                        can be assigned at a time.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="certification" type="tns:CertificationPolicyActionType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Certification action. The operation will proceed. The object will be scheduled for
                        a certification campaign after the operation is done.
                        This action works with certification campaign. Therefore it is ideal for actions that are frequent
                        and can occur on large number of objects. The campaign is an efficient method how to handle mass
                        decisions. However it mat not be started immediately.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="notification" type="tns:NotificationPolicyActionType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Notification action. The operation will proceed. Notifications are sent at the end of the
                        operation. More notification actions can be specified.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="id" type="xsd:long" use="optional"/>
    </xsd:complexType>

    <xsd:complexType name="PolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                Common supertype for policy actions.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="name" type="xsd:string" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        <p>
                            Name for the action. It is used for logging and other diagnostic purposes.
                        </p>
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="description" type="xsd:string" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        <p>
                            Free-form description (e.g. comments about the action purpose)
                        </p>
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="EnforcementPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                Enforcement action. This action stops the operation and results with the error.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <!-- Empty for now.
						 TODO: later add type of error and message -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="ApprovalPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                Approval action. The operation will be suspended and the approval workflow will be started.
                If the workflow ends with success the operation will proceed. If the workflow ends with
                an error the operation will also end with an error.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <xsd:element name="compositionStrategy" type="c:ApprovalCompositionStrategyType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                How should be this approval policy action composed with other ones that
                                might be related to the same item (object or assignment)?
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:choice>
                        <xsd:sequence>
                            <xsd:element name="approverRelation" type="xsd:QName" minOccurs="0" maxOccurs="unbounded">
                                <xsd:annotation>
                                    <xsd:documentation>
                                        <p>
                                            What relation(s) to use when determining approvers? E.g. "approver", "owner",
                                            "securityApprover", and so on.
                                        </p>
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="approverRef" type="c:ObjectReferenceType" minOccurs="0" maxOccurs="unbounded">
                                <xsd:annotation>
                                    <xsd:documentation>
                                        <p>
                                            Direct enumeration of the approvers to be used.
                                            May be used with approverRelation and approverExpression element(s).
                                        </p>
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="approverExpression" type="c:ExpressionType" minOccurs="0" maxOccurs="unbounded">
                                <xsd:annotation>
                                    <xsd:documentation>
                                        <p>
                                            Expression(s) that yield approvers to be used. If specified, the expression(s) are evaluated and
                                            the result is used as a set of approvers (UserType, OrgType, RoleType, or any combination of them).
                                            May be used with approverRelation and approverRef element(s).
                                        </p>
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:sequence>
                        <xsd:element name="approvalSchema" type="c:ApprovalSchemaType" minOccurs="0" maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation>
                                    <p>
                                        More complex (multi-stages) approval schema.
                                    </p>
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="approvalProcess" type="xsd:string"
                                     minOccurs="0" maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation>
                                    <p>
                                        Name of custom approval process.
                                    </p>
                                    <p>
                                        THIS PROPERTY (approvalProcess) IS NOT SUPPORTED YET.
                                    </p>
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:element name="automaticallyApproved" type="c:ExpressionType" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                <p>
                                    Condition specifying when the approval is automatically granted (e.g.
                                    "user is from Board of Directors"). This is an expression that should yield a
                                    boolean value.

                                    DEPRECATED. Use automaticallyCompleted in approval level definition.
                                </p>
                            </xsd:documentation>
                            <xsd:appinfo>
                                <a:deprecated>true</a:deprecated>
                                <a:deprecatedSince>3.6</a:deprecatedSince>
                            </xsd:appinfo>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="ApprovalCompositionStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                Prescribes how individual approval requirements should be composed into overall approval schema.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="order" type="xsd:int" minOccurs="0"/>
            <xsd:element name="exclusive" type="xsd:boolean" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        If set to true, this fragment might be the only one with this particular order number.
						(Other fragments could be merged into it, but in "mergeIntoOrder" mode. TODO TODO TODO)
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="mergeable" type="xsd:boolean" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        If set to true, this schema fragment is eligible to merging with other fragments of the same order.
                        (Non-mergeable fragments with the same order are ordered randomly. Mergeable fragments must have
                        order filled-in.)

						Mergeable fragments must have "order" attribute set.

                        Restrictions on merging schema fragments:
                        1) Mergeable fragments must contain exactly one stage. It is merged with the stage(s) of the other
                        fragment(s) without any further considerations (e.g. regarding stage order or name or whatever).
                        2) It is expected that single policy rule triggered all the fragments that are being merged. So
                        we consider any of these rules.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="mergeIntoOrder" type="xsd:int" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Which fragments should this one be merged with. This is mutually exclusive with the "order" attribute.
						If order is set, it is not possible to specify mergeIntoOrder. Both fragments with the same order are
						considered "equal". This can be used e.g. to provide a different set of approvers (for the given stage).
						If mergeIntoOrder is set (usually with multiple values), this fragment is considered as an augmentation
						of other ones. This can be used e.g. to provide an escalation or notification strategy, custom form information, etc.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element><xsd:element name="mergeIntoAll" type="xsd:boolean" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Indicates that this fragment is to be merged into all the other "base" fragments.
						This is mutually exclusive with the "order" and "mergeIntoOrder" attributes.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="mergePriority" type="xsd:int" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Provides an information about order in which this fragment is merged (lower numbers are processed before higher ones).
					</xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="mergeOverwriting" type="xsd:QName" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        If stage B is being merged into existing stage A (i.e. mergeOrder B is greater mergeOrder A),
                        all non-null values of B will be added to values of A; overwriting them in case of single-valued items.
                        For items marked as "mergeOverwriting", the actual values of B (even those that are null or empty)
                        overwrite those in A.
                    </xsd:documentation>
                    <xsd:appinfo>
                        <a:since>3.6</a:since>
                        <a:experimental>true</a:experimental>
                    </xsd:appinfo>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="RemediationPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                TODO
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <!-- TODO -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="PrunePolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                TODO
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <!-- TODO -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="CertificationPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                TODO
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <xsd:element name="definitionRef" type="c:ObjectReferenceType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                <p>
                                    Certification definition(s) to be started as part of the action execution.
                                </p>
                            </xsd:documentation>
                            <xsd:appinfo>
                                <a:objectReferenceTargetType>tns:AccessCertificationDefinitionType</a:objectReferenceTargetType>
                                <a:since>3.6</a:since>
                            </xsd:appinfo>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="NotificationPolicyActionType">
        <xsd:annotation>
            <xsd:documentation>
                TODO
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tns:PolicyActionType">
                <xsd:sequence>
                    <!-- TODO -->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="PolicyExceptionType">
        <xsd:annotation>
            <xsd:documentation>
                Recorded exception from a policy rule. The exceptions that are approved are
                recoded here to avoid re-evaluating and re-approving them all the time.
                This is EXPERIMENTAL functionality. It is likely to change in the near future.
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.5</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="ruleName" type="xsd:string" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        <p>
                            Name for the rule for which this is an exception.
                        </p>
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="policySituation" type="xsd:anyURI" minOccurs="0" maxOccurs="1">
                <xsd:annotation>
                    <xsd:documentation>
                        <p>
                            Policy situation for which this is an exception.
                        </p>
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <!-- TODO: validity? -->
            <xsd:element name="metadata" type="tns:MetadataType" minOccurs="0"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="PolicyRuleEnforcerHookPreviewOutputType">
        <xsd:annotation>
            <xsd:documentation>
                TODO
                EXPERIMENTAL
            </xsd:documentation>
            <xsd:appinfo>
                <a:container />
                <a:since>3.7</a:since>
                <a:experimental>true</a:experimental>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element name="rule" type="tns:EvaluatedPolicyRuleType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        <p>
                            TODO
                        </p>
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexType>


</xsd:schema>
